* Интро

* Выводы на 21.05:

** Общие замечания:
- не перебивать
- выждать 3 сек прежде чем ответить
- произносить максимум 20 слов, потом заткнуться
- не говорить о том, о чем не спрашивают (не сообщать лишних подробностей
  о себе)
- когда просят рассказать о себе, спросить, читали ли они резюме и что их
  конкретно интересует
- сформулировать для работодателей минимум 5 вопросов
- сформулировать цели: что интересно, как вижу свое развитие, чем
  планирую заниматься (компиляторы и проектировка язков
  программирования)
- не унижать свои проекты и достижения

** Общие пробелы:

- пройти самые распространненые сортировки
- пройти структуры данных: авл-деревья, хэш-таблицы и т.д.

  Красно-черное дерево:
[[file:red_black_tree.org]]

  Бинарное дерево:
[[file:bin_search.org]]

  B-дерево:
[[file:b-tree.org]]

- для каждого алгоритма знать сложность
  [[file:./o-notation.org]]

- выяснить, как работает ОС: виртуальная память, процессы (как
  распределяется память, стек, планируются потоки, не путать потоки с
  фиберами)

  Процессы:
  [[file:./process-os.org]]

  Потоки:
  [[file./threads.org]]

- подтянуть терминологию
- освежить сикп: сопоставление паттернов (пролог), задержаные вычисление,
  недетерминистские вычисления

- выяснить про мьютексы, семафоры, lock-free алгоритмы

  Синхронизация:
  [[file:./synchronization-os.org]]

- постгресс
- докер
- командная строка
- разобраться в классификации языков: статически/динамически
  типизированные, императивные/функциональные, сильно
  типипзированные/слабо типизированные и т.д.

** Конкретные вопросы:

*** Чем отличаются потоки от фиберов (горутин)?

Ответ:
- ~управдение~: потоки управляются ОС, горутины - рантаймом языка го

- ~размер стека~: потоки имеют фиксированный размер стека, стек в горутнах растет до 1
  гига на 64-рязрядах, и до 250 мб на 32-разрядах

- ~переключение контекста~ у потоков осуществляется в нуевом кольце, у
   горутин - рантаймом языка

*** Как в го GC получает начальное дерево ссылок? Как GC вообще работает?


- Можно ли реализовать ~delay~ из сикпа (см. главу про задержанные
  вычисления) не через особую форму? Ответ: нет, нельзя, это
  макрос. Объяснить, почему нельзя.

  Ответ:
  Нет, нельзя. Delay - это фактически синтаксический сахар для лямбды,
  это макрос.

  Задержанное вычисление оборачивается в безагументную лямбду, которую
  можно вынудить к вычислению процедурой ~force~.

  Благодраря задераным вычислениям можно заниматься условно бесконечным
  вычислением - например, породить ряд всех положительных чисел - не
  боясь зависнуть в вычислении.

- Почему не пошла получать вторую вышку? Ответ: в универах много
  ненужного мусора, жрет много времени, а КПД низкий.
- Почему нужно закрывать каналы в го? Почему их не может потом подчистить
  GC? Ответ: утечка памяти
- Может ли один процесс получить доступ к памяти другого процесса?
- Почему расстмариваю эрланг? Ответ: люблю функциональные языки и всегда
  готова изучать новый язык.
- для чего оценивать алгоритмы? По каким критериям оцениваются?

* Выводы на 28.05

** Общие замечания
** Общие пробелы
** Конкретные вопросы
** Тестовое задание

Необходимо реализовать сервис коротких ссылок.

Требования к функциональности:
Сервис должен позволять выполнять следующие действия через HTTP:
- добавлять новую короткую ссылку (на вход получает полный URL, в ответе
сервис отдаёт новую короткую ссылку)
- перейти по короткой ссылке и получить редирект на полную ссылку
- если указанная короткая ссылка не существует в системе, то отдавать 404
- просмотреть статистику по посещениям:
- общее количество запросов на переход по короткой ссылке
- статистику по посещениям можно писать в консоль или предоставить
отдельную HTTP-API, которая отдаст текущее значение счётчика
посещений (редиректов)

Ограничения к системе:
Код должен быть рабочим, запускаемым, обязательно с инструкцией по
запуску.
Для реализации можно использовать любые возможности языка go 1.14 и выше
и любые вендорные библиотеки. Карту со ссылками можно хранить как в базе
данных, так и в памяти приложения (на усмотрение кандидата).
Если сервис хранит все данные в памяти, допустимо потерять все
сохраненные данные при перезапуске приложения.

Не обязательно, но будет плюсом:
Реализовать простейший фронтенд, использующий данное API (можно
server-side-render на golang/templates, можно любой js-фреймворк: react,
vuejs, angular).
Использовать любые приемы, позволяющих сократить потребление памяти и
процессорного времени с пояснением (хотя бы в теории).
Любые тесты, конечно, приветствуются.
Не используйте название компании нигде в коде или названиях контейнеров
или ресурсов, адресах.


*** Разжевываем
Есть интересное здесь:
https://www.educative.io/courses/grokking-the-system-design-interview/m2ygV4E81AR


Получается у нас 3 связанных друг с другом значения:
- длиная ссылка
- короткая ссылка
- счетчик посещений

Есть три варианта взаимодействия с сервисом:
- получить новую короткую ссылку
- пройти по короткой ссылке (возможны 2 исхода): короткая ссылка есть -
  тогда редирект на длинную ссылку; короткой ссылки нет - вернуть ошибку
  404
- запросить счетчик посещений для короткой ссылки

Два враианта организовать данные:
- хэш-таблица, где ключ - это короткая ссылка, а значение - это длинная
  ссылка и счетчик посещений (например, структура)
- БД

Пробуем сначала организвать ввиде хэш-таблицы.


Как генерировать короткую ссылку?
Используем хэш от введенного длинного урла, сокращенный до 10 символов.

SHA-256 (исп. символы от 0 до 9 и от a до f) - это 10 000 000 000 000 000
возможных компбинаций по 10 символов. Т.е. шанс, что после обрезки хэша
до 10 символов у нас получится 2 одинаковых ключа = 1 из 10 000 000 000 000 000.

http://localhost:8080/get_full_url/ac6bb669e4

#+NAME dfs_go
#+BEGIN_SRC go :tangle 28_05_test_ex.go
  package main

  import
  (
      "crypto/sha256"
      "fmt"
      "net/http"
  )


  type fullUrl struct {
      Cnt int
      Url string
  }

  var tableOfLinks = make( map[string]fullUrl )
  var hash string

  func generateShortURL (link string) string {

      sum := sha256.Sum256( []byte( link ) )
      // почему в этом случае я получаю массив с длиной 10?
      // что за кодировка?
      fmt.Printf("%x \n", sum)

      // fmt.Println(sum)
      return string(sum[:5])
  }

  func getFullUrl( shortUrl string ) (string, int) {

      val, ok := tableOfLinks[shortUrl]
      fmt.Printf("val %s \n", val.Url)

      if ok == true {
          return val.Url, 303
      }
      return "", 404
  }

  // func redirect( shortUrl string ) {
  // 	url, err := getFullUrl( shortUrl )
  // 	resp, err := http.Get( url )

  // }

  func redirect( w http.ResponseWriter, r *http.Request ) {
      path := []byte(r.URL.Path)
      shortUrl := string(path[len(path)-10:])


      fmt.Printf("path %s \n", path)
      fmt.Printf("shortUrl %s \n", shortUrl)

      // не совпадают кодировки?
      if hash  != shortUrl {
          fmt.Printf("Not equal \n")
          fmt.Println( []byte( hash ) )
          fmt.Println( []byte( shortUrl ) )
      }

      // url, statusCode := getFullUrl( shortUrl )
      url, statusCode := getFullUrl( string( hash ) )

      if statusCode == 303 {
          http.Redirect(w, r, url, http.StatusSeeOther)

      } else {
          http.Redirect(w, r, shortUrl, http.StatusNotFound)
      }
  }

  func main () {

      s := &http.Server{
            Addr:           ":8080",
      }

      link := "https://www.google.com"
      hash = generateShortURL(link)
      fmt.Printf("hash %x \n", hash )

      test := fullUrl{ Url: link }
      tableOfLinks[hash] = test

      Url, _ := getFullUrl( hash )
      fmt.Printf("Url %s \n", Url )

      http.HandleFunc("/get_full_url/", redirect)
        //запускаем сервер
      s.ListenAndServe()

  }
#+END_SRC
