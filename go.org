* Интро
Шпаргалки по голангу.


Шпаргала для собесов по го и не только.

* Упреждающее планирование с фиксированным приоритетом

- планировщик обеспечивает в первую очередь выполнение тех задач, которые
  обладают бОльшим приоритетом среди всех задач, которые готовы к
  выполнению в данный момент

- в таком планировании процесс может переходить только из состояний
  ожидания/выполнения в состояние готовности

- основная задача планировщика - планирование времени. Устанавливается
  временной срез - таймер. По его истечении планировщик переключает
  контекст на другой поток.

- плюсом такой системы является то, что система отслеживает, какие
  процессы задерживают процессор на время, большее заданного таймера.

- минусы:
  - из-за того, что задачи выполняются в соответствии с приоритетом,
    выполнение задач с более низким приоритетом может занять
    неопределенное количество времени. Решение такое проблемы - это
    старение: т.е. процесс постепенного повышения приоритетов задач.

* Кооперативное (неупраждающее) планирование

- процессы могут перейти из режима ожидания в режим ожидания

- процесс не может быть прерыван до своего завершения/перехода в режим ожидания

- процесс удерживает все ресурсы до своего завершения/перехода в режим ожидания


* Фиберы vs потоки

Потоки:
- используют упреждающее планирование (pre-emptive scheduling)
- могут быть вытеснены другими потоками или остановлены на середине
  выполнения - из-за этого есть проблема с сохранностью данных.
- весь гемор по их управлению - разделение общих ресурсов,
  корректное завершение и т.д. ложится на разраба.

Фиберы:
- используют совместное (кооперативное, непрерывное) планирование (cooperative scheduling)
- могут быть остановлены/вытеснены другими фиберами только в случае, если
  фибер завершил работу, либо в какой-то другой корректной точке -
  т.е. нужно указать явно, что фибер сейчас должен быть вытеснен или еще
  что-то. Сохранность данных поэтому - куда меньшая проблема
- переключать контекст - куда менее дорогостоящее занятие (почему?)


* Горутины
** Что такое горутина

Горутина - это по сути фибер, т.е. легковесный поток, который управляется
рантаймом языка го. Можно запускать тысячи горутин в одном потоке (как
это работает? поток постоянно меняет контекст и исполняет то ту, то эту
горутину?).

Каждая горутина представлена объектом ~g~ - структурой.

Первое поле этой стрктуры - это ~stack~, потому что у каждой горутины
свой стек. Со старта его размер 2 кб. Если функция, выполняющаяся в
горутине, требует большего объема стека, то выделается еще страница. Но
максимальный размер стека на 32-разрядной системе составляет 250 байт, а
на 64-разряной - 1 гигабайт.

Сорцы структуры здесь
https://github.com/golang/go/blob/f296b7a6f045325a230f77e9bda1470b1270f817/src/runtime/runtime2.go#L395
#+NAME: type_g
#+BEGIN_SRC go :noweb yes
  type g struct {
      stack       stack   // offset known to runtime/cgo
      stackguard0 uintptr // offset known to liblink
      stackguard1 uintptr // offset known to liblink
      <<panic>>
#+END_SRC

Затем идет поле ~panic~. Оно содержит указатель на структуру типа
~panic~ - эта структура хранит информацию об активной
"панике",т.е. ошибке, возникшей в выполнении программы. Значения этой
структуры всегда находятся на стеке

#+NAME: panic
#+BEGIN_SRC go :noweb yes
  _panic       *_panic
  <<defer>>
#+END_SRC

Поле ~defer~ представляет собой указатель на структуру ~defer~. Эта
структура содержит в себе информацию о ~call~, который мы пометили как
~defer~: т.е. вызов функции выполнится после того, как выполнятся все
вызовы вокруг него, хотя аргументы вызова вычислены сразу.

#+NAME: defer
#+BEGIN_SRC go :noweb yes
  _defer       *_defer
  <<m_ptr>>
#+END_SRC

В поле ~m~ хранится указатель на структур ~m~ - структуру открытого
потока ОС. Скорее всего, это структура потока, в котором будет
выполняться горутина.

#+NAME: m_ptr
#+BEGIN_SRC go :noweb yes
  m            *m
#+END_SRC

Пропустим поля ~sched~, ~syscallsp~, ~syscallpc~, их смысл пока не очень
понятен.

Дальше идет ~stktopsp~, судя по всему, это указательна вершну стека
горутины, чтоб всегда можно было сделать бэктрейс.

#+NAME: stktopsp
#+BEGIN_SRC go :noweb yes
  stktopsp     uintptr
#+END_SRC

Поле ~param~ содержит в себе указатель на параметр, переданный горутине
при пробуждении. Подозреваю, что это не указатель на параметры функции,
которая вызывается в горутине.

#+NAME: defer
#+BEGIN_SRC go :noweb yes
  param        unsafe.Pointer // passed parameter on wakeup
#+END_SRC

Пропустим еще несколько полей.
Поле ~waitsince~ содержит примерное время, когда горутина была
заблокирована:

#+NAME: defer
#+BEGIN_SRC go :noweb yes
  waitsince    int64      // approx time when the g become blocked
  waitreason   waitReason // if status==Gwaiting
#+END_SRC

И прочие поля:
#+BEGIN_SRC go

  preempt       bool // preemption signal, duplicates stackguard0 =
  stackpreempt
  preemptStop   bool // transition to _Gpreempted on preemption;
                     // otherwise, just deschedule
  preemptShrink bool // сократить стек к какой-то синхронной точке

  asyncSafePoint bool // это поле установлено, если горутина была
                      // остановлена в асинхронной
                      // точке. This means there are frames on the stack
                      // without precise pointer information.

  paniconfault bool   // поле устанавливается в случае, если во время
                      // исполнения горутины
                      // возникла ошибка

  gcscandone   bool   // g has scanned stack; protected by _Gscan bit in
  status
  throwsplit   bool    // must not split stack

  activeStackChans bool  // показывает, есть ли незаблокированные каналы,
                         // указывающие куда-то
                         // в стек горутины. Если это так, то
                         // устанавливается защита этих областей стека

  raceignore     int8     // ignore race detection events
  sysblocktraced bool     // StartTrace has emitted EvGoInSyscall about
                          // this goroutine
  sysexitticks   int64    // cputicks when syscall has returned (for
                          // tracing)
    traceseq       uint64   // trace event sequencer
    tracelastp     puintptr // last P emitted an event for this goroutine
    lockedm        muintptr
    sig            uint32
    writebuf       []byte
    sigcode0       uintptr
    sigcode1       uintptr
    sigpc          uintptr
    gopc           uintptr         // pc of go statement that created this
    goroutine
    ancestors      *[]ancestorInfo // ancestor information goroutine(s)
    that created
                                   // this goroutine (only used if
    debug.tracebackancestors)
    startpc        uintptr         // pc of goroutine function
    racectx        uintptr
    waiting        *sudog         // sudog structures this g is waiting on
                                  // (that have a valid elem ptr); in lock
    order
    cgoCtxt        []uintptr      // cgo traceback context

    labels         unsafe.Pointer // profiler labels
    timer          *timer         // cached timer for time.Sleep
    selectDone     uint32         // are we participating in a select and
    did someone
                                  // win the race?

    // Per-G GC state

    // gcAssistBytes is this G's GC assist credit in terms of
    // bytes allocated. If this is positive, then the G has credit
    // to allocate gcAssistBytes bytes without assisting. If this
    // is negative, then the G must correct this by performing
    // scan work. We track this in bytes to make it fast to update
    // and check for debt in the malloc hot path. The assist ratio
    // determines how this corresponds to scan work debt.
    gcAssistBytes int64
  }
   #+END_SRC

* Планировщик го

Сорцы здесь
https://github.com/golang/go/blob/f296b7a6f045325a230f77e9bda1470b1270f817/src/runtime/proc.go#L19

Задача планировщика - распределить готовые к исполнению горутины по
работающим потокам ОС.

Есть три главные концепции (аббревиуатры):
- ~G~ - это сама горутина, в документации ей соответствует ~type g~ -
  структура горутины. Когда горутина завершает свою работу, ее структура
  возвращается в пулл доступных структур, чтоб новая горутина могла ее
  занять.
- ~M~ - рабочий поток, у него тип ~type m~.
  У каждого рабочего потока есть свой системный стек. Этот стек, в
  отличие от стека горутины, не умеет расти. Но он изначально достаточно
  большой, чтоб это не потребовалось.
- ~P~ - контекст планирования, необходимый для выполнения кода, который
  мы хотим исполнить через горутину. ~P~ обозначает ~type p~.

Структуры ~g~, ~m~ и ~p~ выделяются в куче, но при этом эта память не
совобождается. Следовательно, когда какая-то структура становится не
нужна, она просто перезаписывается новыми данными другой структуры такого
же типа - по крайей мере, я не могу придумать другой механизм, который
позволяет не освобождать память в куче, но при этом не исчерпать ее.
Подозреваю, что ~GC~ - сборщик мусора - следит за тем, какие структуры
можно переписывать, а какие нет.


** Методы организации многопоточных вычислений

Есть два варианта, как нарезать вычисления на потоки:
1. Несколько пользовательских потоков оздаются внутри одного потока
   ОС. Плюсы - быстрое переключение контекста (т.е. когда сохраняются все
   регистры и стек, вычисление переходит на другой поток, потом
   сохраняется его состояние регистров и стека, и управелние переходит на
   поток, с которого ушли, и вычисление возобоновляется ровно с той
   точки, с которой ушли). Минусы - не используются преимущества
   многоядерных машин.

2. Каждому потоку пользователя соответствует поток оси. Из плюсов -
   используем преимущества многоядерных машин, из минуосв - контекст
   переключать долго.

** Организация многопоточных вычислений в го

Как это делает го: на каждом потоке оси запускается множество
пользовательских потоков. Таким образом получаем плюсы от обоих
подходов.

Получается, что для каждого ~M~ - потока оси - существует свой ~P~ -
контекст планирования, на котором исполняется ~G~ - горутина. Когда
горутина завершается, ее объект помечается как свободный. И потом ~M~
может использовать его для новой горутины. А если потом ~M~ завершается,
то он его ~P~ - контекст планирования - возвращается в пулл и его может
использовать новый поток ~M~.

Поток ~M~ должен удерживать свой (?) контекст. Количество одновременно
удерживаемых контекстов задается переменной ~GOMAXPROCS~ или функцией
периода выполнения ~GOMAXPROCS()~. Эта величина не изменяется на
протяжении выполнения програмы и обозначает, сколько участков кода GO
(потоков ~M~ ? ) может быть выполнено одновременно.

Тем не менее, это правило вполне может нарушаться.

Горутины, которые еще не выполняются, но готовы для планирования,
находятся в списках - очередях, которые называются ~runqueues~. Каждый
раз, когда вызывается оператор ~go~ - создание горутины - планировщик
берет первую горутину из очереди, настраивает ей стек и ~rip~ и горутина
начинает исполняться. А в конец очереди помещается новая горутина,
готовая для планирования (?). Такое состояние системы называется
устойчивым.

Каждый контекст ( потока ~M~ ?) обладает своей собственной очередью
исполнения. Если бы была только глобальная очередь для всей контекстов,
то ее постоянно приходилось бы лочить мьютексами, а это долго.

Но, тем не менее, глобальная очередь есть - в ней тоже хранятся горутины
на случай, если они закончатся в локальных очередях. А контексты потоков
~M~ периодически проверяют, нет ли в глобальной очереди горутин, иначе
они никогда не исполнятся

** Обработка системных вызовов

Это пример неустойчивого состояния системы.

Потоки ~M~ могут передавать свои контексты - за этим контексты и
нужны. Если поток будет заблокирован по какой-то причине -
например,какой-то горутине нужно исполнить системный вызов - то он
передаст весь свой контекст другому, возможно даже специально созданному
ради этого потоку ~M~, и на этом новом потоке будет продолжаться
вычисление (у нас же могут быть сотни горутин запущены в одном потоке).

И это именно тот случай, когда переменная ~GOMAXPROCS~ установлена в 1, а
потоков ~M~ оказывается два (или больше, если еще какая-то горутина
зависнет).

Когда системный вызов исполнится и исходный поток ~M~ вернется к жизни,
то ему нужно получить контекст обратно, чтоб доисполнить горутину,
которая вызывала системный вызов. Обычно он заимствует контекст у
какого-то другого потока. Если заимствовать контекст не удалось, то поток
возвратит горутину в глобальную очередь горутин, после чего поток либо
завершается, либо засыпает.

*** Заимствование работы (горутин)

Это еще один пример неустойчивого положения в системе.
Предположим, какой-то контекст - поток ~M~ исчерпал свою локальную
очередь исполнения, а при этом есть еще какой-то объем кода, который
предстоит выполнить.

Завершать поток в таком случае - глупо. Поэтому поток смотрит в
глобальную очередь горутин и берет их оттуда, и продолжает исполнение.
Если же горутины кончились и в глобальной очереди, то поток попробует
позаимствовать горутины из других потоков - свиснуть примерно половину у
кого-то из них. Таким образом получается, что работа есть для каждого
потока.

** Синхронизация
Полезная статья
https://github.com/golang/go/blob/release-branch.go1.14/src/runtime/HACKING.md

Рантайм го имеет несколько механизмов синхронизации.

~Мьютекс~
Мьюеткс хорошо использовать для короткой блокировки разделяемых
ресурсов. Мьютекс блокирует весь поток ~M~, но делает это в обход
планировщика. В результате планировщик не перебросит контекст
заблоченного потока другому потоку, и все горутины, работающие на этом
потоке, токе окажутся заблокированны.

~Каналы~
Это более дешевый метод синхронизации. Мы можем создать канал, в который
одна горутина будет писать, а другая горутина будет из него
читать. Операции с каналами являются блокирующими по умолчанию для
горутин. Это значит, когда горутина, записавшая что-то в канал, будет
заблокирована до тех пор, пока другая горутина не прочитает из этого
канала. Поэтому возможно, чтоб две или более горутин писали в один канал,
а другая горутиа считывала эти значения: первая записала -
заблокировалась, ждет чтения, вторая записала - заблокировалась, ждет,
пока прочитают, третья горутина прочитала два значения - первая и вторая
горутины разблокировались.

* Протокол HTTPS

Представляет собой "обертку" для http. Это просто защищенный
криптографией http.

Защиту осуществляет TLS

** Протокол TLS
Криптографический протокол, наследник SSL.

Оба этих протокола используют ассиметричное шифрование для аутентификации
и симметричное - для передачи данных.

*** Ассиметричное шифрование
Есть пара ключей: открытый и закрытый. И к тому же сущетвует электронная
подпись. Закрытым ключом расшифровывается сообщение, а открытым -
верифицируется электронная подпись.

Открытый ключ передается по открытому каналу. Его утечка не приводит к
потере безопасности.

Основные принципы:

- Можно сгенерировать пару очень больших чисел (открытый ключ и закрытый
  ключ) так, чтобы, зная открытый ключ, нельзя было вычислить закрытый
  ключ за разумный срок.
  При этом механизм генерации является общеизвестным.

- Имеются надёжные методы шифрования, позволяющие зашифровать сообщение
  открытым ключом так, чтобы расшифровать его можно было только
  закрытым ключом. Механизм шифрования является общеизвестным.

- Владелец двух ключей никому не сообщает закрытый ключ, но передает
  открытый ключ контрагентам или делает его общеизвестным.

*** Симметричное шифрование

Для зашифровки и расшифровки сообщения используется один и тот же ключ.
Требование для успешного симметричного шифрования:

- полная утрата всех статистических закономерностей исходного сообщения.
  Для этого шифр должен иметь «эффект лавины» — должно происходить сильное изменение шифроблока
  при 1-битном изменении входных данных

- отсутствие линейности

Этапы установления соединения:

- клиент подключается к серверу, поддерживающему TLS, и запрашивает
  защищённое соединение;

- клиент предоставляет список поддерживаемых алгоритмов шифрования и
  хеш-функций;

- сервер выбирает из списка, предоставленного клиентом, наиболее
  надёжные алгоритмы среди тех, которые поддерживаются сервером, и
  сообщает о своём выборе клиенту;

- сервер отправляет клиенту цифровой сертификат для собственной
  аутентификации. Обычно цифровой сертификат содержит имя сервера, имя
  удостоверяющего центра сертификации и открытый ключ сервера;

- клиент, до начала передачи данных, проверяет валидность
  (аутентичность) полученного серверного сертификата относительно
  имеющихся у клиента корневых сертификатов удостоверяющих центров
  (центров сертификации). Клиент также может проверить, не отозван ли
  серверный сертификат, связавшись с сервисом доверенного удостоверяющего
  центра;

- для шифрования сессии используется сеансовый ключ. Получение общего
  секретного сеансового ключа клиентом и сервером проводится по протоколу
  Диффи-Хеллмана.

*** Протокол Диффи-Хеллмана

Есть два абонента: Лиза и Маша. Им обоим изветно некоторые два простых числа g и p,
числа не являются секретными ни для кого - в том числе для третьей
стороны.

Лиза и Маша геренируют два больших случайных числа А и В и передают друг другу
остаток от деления: А = g^a mod p и В = g^b mod p. После этого
каждый вычисляет закрытый ключ на основе имеющегося у него большого
сгенерированного числа и остатка от деления, полученного по сети.

В результате они получают одно и то же число, которое и является закрытым
ключом. И хотя алгоритм общеизвестен, числа настолько большие, что
невозможно подобрать ключ достаточно быстро.

*** Сертификат

По сути это файл, который содержит в себе электронную подпись, которая
связывает открытый ключ с его принадлежностью: т.е. данный открытй ключ
принадлежит серверу/клиенту.

Чтобы сертификату доверял любой веб-браузер, он должен быть подписан
аккредитованным удостоверяющим центром (центром сертификации, Certificate
Authority, CA). CA – это компании, выполняющие ручную проверку, того что
лицо, пытающееся получить сертификат, удовлетворяет следующим двум
условиям:

1. является реально существующим;

2. имеет доступ к домену, сертификат для которого оно пытается получить.

** Уязвимости HTTPS

*** Человек посередине

Атака происходит в момент обмена ключами между сторонами.
Маша отправляет Лизе сообщение со своим "остатком от деления". Хакер
перехватывает это сообщение и отправляет вместо него - свой остаток от
деления. Аналогично он поступает и с сообщением от Лизы.

В результате Маша и Лиза уверены, что общаются друг с другом, а на деле
вся связь проходит через третью сторону.

*** POODLE

Ее суть заключается в следующем: хакер вынуждает клиента выполнить
подключение по SSL 3.0, эмулируя разрывы связи. Затем он ищет в
зашифрованном трафике специальные сообщения-метки. С помощью
серии подставных запросов злоумышленник получает возможность
реконструировать содержимое интересующих его данных, например cookies.

Хотя SSL 3.0 - устаревший протокол, он все еще используется, чтоб
поддерживать совместимость с серверами.

Защититься можно двумя способами:
- отключить поддержку SSL 3.0
- запретить обмен данными по SSL 3.0 для всех систем, которые в состоянии
  поддерживать другой протокол, TLS например.

*** BEAST

Злоумышленники внедряют на клиентскую машину JavaScript-агент или
Java-апплет, который подменяет сообщения при трансляции данных по TLS или
SSL. Так как злоумышленникам известно содержание «подставных» пакетов,
они могут с их помощью расшифровать и прочитать остальные сообщения к
серверу, например cookie-файлы для аутентификации.

Защитться можно:
- атакующему необходимо постоянно отправлять запросы. Поэтому следует
  установить SSL SessionCacheTimeout — с пяти минут (рекомендация по
  умолчанию) до 30 секунд. Такой подход усложнит реализацию планов
  злоумышленникам, хотя и окажет некоторый негативный эффект на
  производительность.
