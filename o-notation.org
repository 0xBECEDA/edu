* Интро
  Файл по о-нотации: зачем, как рассчитывать, сложность алгоритмов.

* Деревья (вставка, поиск, удаление узла)

** Бинарное дерево поиска

Расход памяти: O(n)
Поиск, вставка, удаление:
Дерево сбалансировано (лучший случай): O(logN)
Иначе: O(n)

** Красно-черное дерево

Это самобалансирующееся дерево, поэтому:
Расход памяти: O(n)
Поиск, вставка, удаление: O(logN)

** B-дерево

Дерево самобалансирующееся, поэтому:
Поиск, вставка, удаление: O(logN)

** 2-3 дерево

Это B-дерево, где у каждого узла может быть либо 2, либо 3 потомка.
Дерево самобалансирующееся, поэтому:
Поиск, вставка, удаление: O(logN)

** АВЛ-дерево

Сбалансированное по высоте двоичное дерево поиска.

Расход памяти:
- в лучш. и в худшем случае О(n)

Поиск, вставка, удаление:
- в лучш. и в худш случае О(logN)

* Хэш-таблицы
* Алгоримы обхода деревьев (графов)
* Сортировки
