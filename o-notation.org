* Интро

  Файл по о-нотации: зачем, как рассчитывать, сложность алгоритмов.

* Статьи

Все алгоритмы в таблице:
https://habr.com/ru/post/188010/

* Деревья (вставка, поиск, удаление узла)

** Бинарное дерево поиска

Расход памяти: O(n)
Поиск, вставка, удаление:
Дерево сбалансировано (лучший случай): O(logN)
Иначе: O(n)

Реализация и описание алгоритма:
[[file:bin_search.org]]

** Красно-черное дерево

Это самобалансирующееся дерево, поэтому:
Расход памяти: O(n)
Поиск, вставка, удаление: O(logN)

Реализация и описание алгоритма:
[[file:red_black_tree.org]]

** B-дерево

Дерево самобалансирующееся, поэтому:
Поиск, вставка, удаление: O(logN)

** 2-3 дерево

Это B-дерево, где у каждого узла может быть либо 2, либо 3 потомка.
Дерево самобалансирующееся, поэтому:
Поиск, вставка, удаление: O(logN)

** АВЛ-дерево

Сбалансированное по высоте двоичное дерево поиска.

Расход памяти:
- в лучш. и в худшем случае О(n)

Поиск, вставка, удаление:
- в лучш. и в худш случае О(logN)


* Хэш-таблицы
* Алгоримы обхода деревьев (графов)

** Обход в ширину

Во всех случаях:
O (V + E), где V - ко-во вершин, а Е - кол-во ребер

[[file:bfs.org]]

** Обход в глубину

Во всех случаях:
O (V + E), где V - ко-во вершин, а Е - кол-во ребер

Реализация:
[[file:dfs.org]]

** Бинарный поиск

В худшем случае О(n)
В лучшем O(logN)

** Перебор элементов

В любом случае О(n)


* Сортировки массивов

** Сортировка пузырьком

В худшем и среднем случае O(n^2)
В лучшем O(n)

** Шейкерная сортировка

В худшем и среднем случае O(n^2)
В лучшем O(n)

** Пирамидальная сортировка

В любом случае O(n logn)

** Сортировка выбором

В любом случае O(n^2)
