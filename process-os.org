* Интро
Шпаргалка по процессам ОС.
Для полного погружения читай Таненбаум "Современные операционные системы", глава 2.

* Определение процесса

Это экземпляр программы со своим идентификатором, памятью, стеком и
счетчиком команд.

* Разница между процессом и программой

Программа - это набор инструкций. Процесс - это выполнение этих
инструкций.


* Разница между потоком и процессом

- у каждого процесса ~своя куча~ и свой стек

- у потоков внутри процесса ~общая куча~ и свой стек

* Реализация процессов

Система ведет ~таблицу процессов~ - массив структур процессов, где каждая
запись соответствует какому-то процессу. ИНогда эти записи называют
блоком управления процессом.

Структура в свою очередь включает в себя такие поля как:

- идентификатор процесса

- файловые дескрипторы

- переменные окружения

- код возврата

- текущий рабочий каталог

- обработчики сигналов

и др.

* Что приводит к созданию процесса

- инициализация системы

- выполнение работающим процессом системного вызова, предназначенного для
  создания процесса: допустим, нужно обработать большой обхъем данных,
  полученных по сети. В этом случае удобно создать вспомогательные
  процессы, где один, например, будет заливать данные в буфер, другой -
  обрабатывать полученные данные, третий - выводить их на экран и т.д.

- запрос пользователя на создание процесса: любая открытая пользователем
  программа, хоть тот же ворд - это новый процесс

- инициализация пакетного задания

* Демоны линукс

Это фоновые процессы, которые могут поддерживать клиент электронной
почты, воспроизводить аудио и т.д.

* Создание процесса (общие сведения)

Все процессы - кроме  init - это дочерние процессы каих-то других
процессов. Каждый процесс имеет свою структуру, среди полей которых -
указатель на выделенную память, стек, идентификатор процесса и т.д.

Подробнее см. атрибуты процессов.

- для создания нового процесса вызывается системный вызов ~fork()~

- ~fork~ создает точную копию родительского процесса, где родительский и
  дочерний процесс имеют единый образ в памяти, одни и те же открытые
  файлы и т.д. И больше ничего

- также дочернему процессу выделяется свое адресное пространство.
  Хотя первоначальное состояние пдресного пространства дочернего процесса
  называется ~копией~ родительского адресного пространства, эти адресные
  пространства не имеют ничего общего - они разные. Изменения в памяти
  родителя не будут видны ребенку и наоборот.

  Некоторые реализации unix-систем изначально не выделяют собственной
  памяти для дочернего процесса, а помечают память родительского как
  ~read-only~ и дают к ней доступ дочернему процессу и дальше используется
  ~copy-on-write~.

- процессу назначается собственный id и стек

- затем процесс становится в очередь готовых к исполнению процессов

У процесса должен быть хотя бы один поток.

* Состояния процесса

- выпоняемый - в данный момент использующий центральный процессор

- готовый - работоспособный, но не исполняющийся в данный момент - ждет
  своей очереди

- заблокированный - не способный выполняться, пока не возникнет какое-то
  внешнее событие

Главное отличие первых двух состояний от последнего в том, что если
процесс залокирован, то он так и останется заблокированным до события,
которое его "оживит" даже в том случае, если процессор не занят и других
процессов на очереди нет. Эта ситуация может возникнуть, когда мы ожидаем
данные из канала, например.

* Обработка прерывания процесса (смена контакста)

Допустим, выполняется несколько процессов. Процессор решает, что текущий
процесс достаточно поработал и должен уступить место другим.

Предположим, что при возникновении дискового прерывания выполнялся
пользовательский процесс. Тогда отправляемся в область памяти, которая называется ~вектором
прерываний~ - в ней содержатся адреса процедур-обработчиков прерываний -
чтоб вызвать обработчик прерывания.

Затем происходит следующее:

- в текущий стек помещается счетчик команд и т. п.
- загружается новый счетчик команд из вектора прерывания
- процедура на ассемблере сохраняет регистры (в запись процесса)
- процедура на ассемблере устанавливает указатель на новый стек
- запускается процедура на языке C, обслуживающая прерывание
(как правило, она считывает входные данные и помещает их в буфер)

- планировщик принимает решение, какой процесс запускать следующим
- процедура на языке C возвращает управление ассемблерному коду
- процедура на ассемблере запускает новый текущий процесс

Так выполнятеся смена контекста.

* Причины завершения процесса

Есть добровольное и принудительное завершение процесса.
Добровольное это:

- обычнй выход
- возникновение ошибки

Принудительное:
- уничтожение другим процессом
- возникновение фатальной ошибки
