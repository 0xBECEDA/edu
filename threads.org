* Интро
Шпаргалка по потокам в ОС.

* Отличие потоков от процессов

- у каждого ~процесса~ ~свое~ адресное пространство и свой стек,
  ~потоки~ могут иметь ~общее адресное пространство~ и общие данные, но
  свой стек - отсюда есть необходимость в синхронизации потоков

- ~процессы~ можно рассматривать как ~способ группировать~ используемые
  ~ресурсы~ (память, обработчики прерываний и т.д.), потоки - это
  "сущность", распределяемая для работы на центральном процессоре

* Почему часто потоки предпочтительнее процессов

- необходимость в общем адресном пространстве

- потоки легче создавать, чем процессы

- производительность - когда выполняются значительные вычисления с
  ожиданием ввода-вывода, то потоки позволяют этим действиям
  перекрываться по времени, что ускоряет процесс

* Состояния потока

- выполняемый

- готовый

- заблокированный

- завершенный

* Варианты реализации потоков

- в пользовательском простраенстве

- в пространстве ядра

- гибридная реализация

* Реализация потоков в пользовательском пространстве

  Когда потоки реализуются в пользовательском пространстве, ядро о них
  ниего не знает, оно по-прежнему продолжает управлять процессами.

  У каждого процесса есть таблица потоков, которая является аналогом
  таблицы процессов у ядра, где каждая запись - это структура с
  атрибутами потока.

  Таблица потоков управляется системой поддержки исполнения программ.
  Когда поток переводится в состояние готовности или блокируется, информация,
  необходимая для возобновления его выполнения, сохраняется в таблице
  потоков, точно так же, как ядро хранит информацию о процессах в таблице
  процессов.

  Когда потом хочет войти в состояние блокировки - например, он ждет
  данные от другого потока - вызывается процедура системы поддержки
  исполнения программ.

  Эта процедура проверяет, можно ли перевести поток в состояние блокировки.
  Если да, то :

- сохраняет значения регитров в структуру потока, его счетчик команд и
  адрес вершины стека

- устанавливает в регистры значения регистров другого потока, новый
  указатель в rsp на стек другого потока, счетчик команд дугого потока

  Как только эти действия выполняются, начинается выполнение другого
  потока.

  Такое переключение контекста куда быстрее, чем перехват управления ядром.

** Недостатки этой реализации

- реализация блокирующих системных вызовов

Если один поток будет реально использовать блокирующий системный вызов, то
это заставит замереть весь процесс вместе со всеми потоками.

Для этого в юникс-системах есть системный вызов ~select~, который
позволяет сообщить вызывающей программе, будет ли какой-то системнй вызов
блокинующим. Если это так, то такой систмный вызов исполняться не будет,
а вместо этого будет запущено исполнение другого потока. Когда мы снова
перейдем к выполнению первого потока, то опять проверим, безопасен ли
системный вызов на этот раз.

- если уже запустился один поток в процессе, то никакой другой поток не
  сможет выполняться, пока первый поток не уступит центральынй процессор.

Проблема в том, что в рамка единого процесса нет прерывания по
таймеру. Это значит, что если поток не уступит ресурсы сам, то у
планировщика и других потоков не будет шансов начать работу.

* Реализация потоков в ядре

Потоки реализованы в ядре и ядро ими управляет.

У ядра есть таблица потоков, в которой отслеживаются все потоки,
имеющиеся в системе. Когда потоку необходимо создать новый или уничтожить
существующий поток, он обращается к ядру, которое и создает или разрушает
путем обновления та-блицы потоков в ядре.В таблице потоков, находящейся в
ядре, содержатся регистры каждого потока, состояние и другая
информация. Вся информация аналогична той, которая ис-пользовалась для
потоков, создаваемых на пользовательском уровне, но теперь она содержится
в ядре, а не в пространстве пользователя.

Все вызовы, способные заблокировать поток, реализованы как системные, с
более существенными затратами, чем вызов процедуры в системе поддержки
исполнения программ. Когда поток блокируется, ядро по своему выбору может
запустить либо другой поток из этого же самого процесса (если имеется
готовый к выполнению по-ток), либо поток из другого процесса.

Плюсы:
- решает проблему с блокирующими системными вызовами

Все вызовы реализованы как системные, когда поток замрет, ядро может
просто запустить другой поток из текущего или другого процесса.

Минусы:
- создание и уничтожение потоков - более затратная операция

Поэтому когда поток надо уничтожить, он просто помечается как
неиспользуемый и перестает исполняться. Но при этом его структура не
уничтожается, и когда нужно создать новый поток, просто активируется один
из уничтоженных.

* Гибридная реализация

Пытаясь решить проблемы в обеих реализациях, создали гибридную
реализацию. Ее суть:

- создаем потоки на уровне ядра
- затем на этих потоках создаем потоки на пользовательском уровне

В результате ядро контролирует только те потоки, которые реализованы на
его уровне.

Создание, удаление и планирование выполнения этих потоков осуществляется
точно так же, как и у пользовательских потоков, принадлежащих процессу,
запущенному под управлением операционной системы, не способной на
многопоточную работу. В этой модели каждый поток на уровне ядра обладает
определенным набором потоков на уровне пользователя, которые используют
его по очереди
