* Тестовое задание для стажера Go-программиста

Необходимо разработать кэширующий http-прокси (обратный прокси).

Условия задачи:
Утилита должна быть конфигурируема. В конфигурационном файле должны
задаваться значения для следующих параметров:
1.	адрес бэкенда (сайт, который будем проксировать);
2.	локальный порт, на котором утилита слушает запросы;
3.	максимальный размер кэша, в количестве записей.

Утилита должна работать следующим образом:
1.	принять HTTP GET запрос;
2.	если url есть в кэше, передать в ответ клиенту файл из кэша;
3.	если url нет в кэше:
    - переслать запрос на бэкенд;
    - прочитать ответ от бэкенда;
    - сохранить запись в кэш, если достигнут максимальный размер кэша
      перезаписать самую старую запись;
    - ответ передать клиенту.

Проксированием http-заголовков можно пренебречь — передаём на бэкенд
только заголовок Host и URL.

Шаги проверки:
1.	в конфигурационном файле задаем адрес бэкенда = «4pda.ru», локальный порт = 8080;
2.	в браузере пишем http://localhost:8080
3.	в браузере открывается страница сайта 4pda.ru.

* Термины и понятия для понимания задания

Полезная статья
https://habr.com/ru/post/506356/

Полезная статья про http и запросы:
https://code.tutsplus.com/ru/tutorials/http-headers-for-dummies--net-8039

** Прокси

   Прокси — это серверное приложение, осуществляющее соединения или запросы
   от своего имени и сетевого адреса в пользу подключившегося к нему
   клиента, пересылая в результате ему все полученные данные.

** Прокси-сервер

   Это сервер-посредник. Через него можно передать сообщение, не раскрывая
   свой реальный адрес, таким образом обходя блокировки. Поэтому во время
   блокировки телега продолжала работать.

   Часто прокси-серверы кэшируют данные с популярных сайтов, поэтому
   загружая данные через прокси-сервер, можно ускорить доступ к этим ресурсам.

   Так же можможно сэкономить трафик, поскольку прокси-сервера могут сжимать
   запрашиваемый контент.

   Из минусов - проблемы с безопасностью
   [TODO:gmm] (какие? как решить?)

** DPI и активные пробы

   Это продвинутый метод проверки и управления сетевым трафиком. DPI
   представляет собой форму фильтрации пакетов, которая обнаруживает,
   идентифицирует, классифицирует, перенаправляет или блокирует пакеты с
   конкретными данными или полезной нагрузкой, которые обычная фильтрация
   пакетов (которая проверяет только заголовки пакетов) не может
   обнаружить.

   DPI проверяет содержимое пакетов, проходящих через заданную точку, и
   принимает решения в режиме реального времени на основе правил,
   назначенных компанией, провайдером или сетевым администратором, в
   зависимости от того, что содержит пакет.

   Более подробно см.сюда
   https://wiki.merionet.ru/seti/20/chto-takoe-texnologiya-dpi/

** Мультиплексирование

   Допустим, с одного и того же компа на один и тот же сервер шлются
   данные из разных приложений через одино и то же
   соединение. Получается, что несколько соединений идут через
   одно. Единственный способ отличить, от кого какие пакеты - это норме
   порта в заголовке пкета.

** http-прокси

   Это прокси-сервер, поддерживающий http-соединения (т.е. сервер ниче не
   шифрует дополнительно, просто пересылает пакеты).

** Запросы HTTP GET

Самый распространенный способ запросить данные у http-серевера.
Зарос состоит из:

- строки запроса
- заголовков

** URL

   Это фактически тот адрес сайта, который мы видим в адресной
   строке. Так пользователь может не вбивать ip ресурса, а пользоваться
   его именем.

   Традиционная форма записи URL:

   <схема>:[//[<логин>[:<пароль>]@]<хост>[:<порт>]][/<URL‐путь>][?<параметры>][#<якорь>]

- схема - сетевой протокол
- логин - им юзера для доступа к ресурсу
- пароль указанного юзера
- хост - полностью прописанное доменное имя или ip
- порт - порт ресурса
- URL-путь - уточняющая инфа о метоположении ресурса, зависит от сетевого
  протокола
- параметры - строка запроса с передаваемыми на сервер параметрами
- якорь - заголовок документа или его id

** Устройство кэша

Что такое кэш:
https://habr.com/ru/company/ruvds/blog/350310/

Виды кэширования:
https://habr.com/ru/company/zerotech/blog/316316/

* Разжевываем задание

  Нужно создать сервер-посредник, который:

 - поддерживает http-сеодинения (т.е. без шифрования)

 - кэширует содержимое ресурсов, к которым уже осуществлялся доступ

 - принимает запросы HTTP GET - т.е. запрос от клиента на какой-то
   ресурс

 - если доступ к ресурсу ранее запрашивался, то сервер возврашает данные
   из кэша клиенту

 - в противном случае сервер запрашивает у ресурса данные от своего
   имени, сохраняет эти данные в кэш - если места больше нет, то
   перезаписывает самую старую запись кэша - и отправляет данные клиенту,
   который их запрашивал

При этом при запуске прокси-сервера мы должны указать:

- сайт, к которому будет осуществляться доступ - ресурс, у которого мы
  будем просить данные

- локальный порт, на котором наш сервер будет слушать запросы

- максимальный размер кэша в количестве записей

** Стек технологий

- Пакет http, там есть все:
https://golang.org/pkg/net/http/

- Postgress для кэширования

* Реализация

Разобьем задачу на подзадачи. Реализуем:

- сервер, принимающий запросы get и просто пересылающий их на сайт, к
  которому клиент хочет получить доступ, и затем возвращающий ответ клиенту

- прокси-сервер, который принимает запросы get и возвращает ответы с
  ресурса, но который меняет в запросах ip-клиента и порт на свой.

- прокси-сервер с кэшированием

** Реализуем первую подзадачу

Что известно на данный момент:

Есть пакет net/http, с помощью которого можно создавать клиенты и сервера
с протоколом http.

Использование этого пакета завязано на двух вещах:
- ServeMux - мультиплексор (маршрутизатор) запросов
- Handler - обработчик

По умолчанию используется ~DefaulServeMux~ если при создании сервера не
было указано обратное. Так же задается функция-обработчик, которую
маршрутизатор вызовет для обработки запроса, сопоставив запрос с
шаблоном, заданным в функции-обработчике.

Иными словами, мы говорим: если запрос начинается с такого-то
символа/слова, то обрабатывать его вот так. БОлее короткие шаблоны имеют
более высокий приоритет по сравнению с более длинными.

Т.е. если есть два шаблона, которые начинаются одинаково, то выбран будет
более короткий.

Запускает слушающий секрвер функция  ~ListenAndServe~, которая принимает
два параметра: порт и маршрутизатор запросов (который по умолчанию ~DefaulServeMux~).

Функция:
- слушает TCP соединения
- как только приходит соединение, выызывает ~Serve~ с заданным
  маршрутизатором запросов, который вызовет нужный обработчик в
  зависимости от того, каким был запрос
- всегда возвращается не nil ошибку

Функция-обработчик запросов запускается с помощью ~http.HandleFunc~,
которая принимает шаблон и функцию, которая будет обрабатывать щапросы,
соответствующие шаблону. Функция-обработчик (судя по поведению программы)
вызывается в отдельной горутине.

Функция-обработчик запросов должна принимать 2 параметра:
- структуру запроса типа ~http.Request~
- объект, соотвтствующий интерфейсу ~http.ResponseWriter~

С запросом все понятно - эта структура заполняется при получении запроса.
С помошью объекта типа ~http.ResponseWriter~ можно сконструировать/ изменить ответ на
этот запрос.

~ResponseWriter~ обладает методами:
- ~Header()~ - возвращет таблицу заголовков, которую ~w.WriteHeader~
  отправит клиенту, сделавшему запрос.

- ~Write()~ - отправляет байтовый массив клиенту
- ~WriteHeader()~ - отправляет заголовки клиенту с статус-кодом.

Если метод ~Write~ был вызван до ~WriteHeader()~, то ~WriteHeader()~
будет вызван неявно и передаст заголовки и статус-код клиенту. Перед тем,
как вызвать ~Write~, нужно прочитать тело ответа и передать
непосредственно его. После того, как все будет передано, тело нужно
закрыть (почему?).

Запросы типа ~Get~ можно посылать с помощью ~http.Get~, который принимает
url как параметр, а возвращает ответ и ошибку, если таковая произошла.

[TODO:gmm] Проблемы:

- почему одни сайты открываются нормально, а другие - нет (не работает
  css, js и т.д., в отладчике в браузере видны ошибки)

- что значит "?" в запросе урла

Запуск текущего сервера:
go build server1.go
./server1

Затем открываем браузер и вводим http://localhost:8080
Должен открыться сайт, чей URL указан в ~TargetURL~.

#+NAME: server1
#+BEGIN_SRC go :tangle server1.go
  package main

  import (
      "net/http"
      "time"
      "log"
      "io"
      "fmt"
  )

  var TargetURL = "http://rigidus.ru"
  // var TargetURL = "https://translate.yandex.ru"
  // var TargetURL = "https://4pda.ru"

  func sendResp ( w http.ResponseWriter, url string) {

      fmt.Printf("url %s \n", url)

      // делаем запрос
      resp, err := http.Get(url)

      if err != nil {
          log.Fatal( err )
      }

      // читаем тело запроса
      body, err := io.ReadAll(resp.Body)


      if err != nil {
          log.Fatal( err )
      }

      // отпарвляем заголовки и статус-код клиенту
      w.WriteHeader(resp.StatusCode)
      fmt.Printf("resp.StatusCode %d \n", resp.StatusCode)

      //отправляем ему тело ответа
      w.Write(body)
      // fmt.Printf("body %s \n", body)

      // после того, как все функции завершились, закрываем тело ответа
      defer resp.Body.Close()
  }

  func getResp ( w http.ResponseWriter, r *http.Request) {
      fmt.Printf("r.URL %s \n", r.URL)

      // создаем url, который будем передавать
      urlstr := fmt.Sprintf("%s?%s", TargetURL, r.URL.RawQuery)
      sendResp ( w, urlstr)
  }

  func initServer() {

      // создаем структуру сервера, устанавливаем в качестве порта 8080,
      // остальные поля по умолчанию
          s := &http.Server{
          Addr:           ":8080",
      }

      // запускаем обработчик запросов
      http.HandleFunc("/", getResp)
      //запускаем сервер
      s.ListenAndServe()

  }

  func main () {
      initServer()
  }
#+END_SRC
