* Интро

* Пакеты

* Panic/recover, defer
https://blog.golang.org/defer-panic-and-recover

** Defer

Defer применяется часто для разнообразных действия "очистки", таких как
закрытие файлов, например.

Она выполняется тогда, когда все функции вокруг нее уже выполнились.
Что нужно знать о defer:

1. Аргументы defer вычисляются тогда же, когда вычисляется само выражение defer.

Пример ниже напечатает "0". Потому что когда вызов Println, обернутый в
defer, был сохранен в списке отложенных вызовов, переменная "i" еще была
равна нулю. То есть аргумент был вычислен в тот момент, когда исполнение
дошло до выражения defer и оно было отправлено в список ожидающих вызовов.

#+NAME: _defer1
#+BEGIN_SRC go :noweb yes
  func a() {
      i := 0
      defer fmt.Println(i)
      i++
      return
  }
#+END_SRC

2. Взовы defer вычисляются в порядке FILO ( что тонко намекает, что
   список отложенных вызовов на самом деле имеет структуру стека - в
   противном случае я не понимаю, зачем добавлять выражения в список, а
   затем вычислять их с конца).

   То есть вызов функции, обернутый в defer, который был встречен
   последним, исполнится первым.

3. Функции, определенные с помощью defer, могут считывать и присваивать
   новые значения именованным возвращающим значениям окружающей их
   функции.

У нас есть окружающая функция ~с()~, которая вернет i типа инт - i и есть
именованное возвращаемое значение окружающей функции. Мы видим, что
окружающая функция ~c()~ всегда возвращает единицу.

Но вутри нее с помощью defer определена безымянная функция (которая
вызовется к тому же), чья единственная задача - инкрементировать
i. Поскольку безымянная функция определена внутри ~c()~, у нее есть
доступ к i.

Мы знаем, что отложенные вызовы исполнятся тогда, когда все функции
вокруг них исполнятся - включая те, внутри которых происходят отложенные
вызовы.

Поэтому, когда с() исполнится и вернет единицу - эта единица попадет в
~i~ - именованное возвращаемое значение. Которое затем инкрементирует
безымянная функция и вернется уже инкрементированное значение.

Таким образом данный пример вернет "2", а не 1, как может показаться.

#+NAME: _defer2
#+BEGIN_SRC go :noweb yes :tangle defer2.go
  package main

  import "fmt"

  func c() (i int) {
      defer func() { i++ }()
      return 1
  }

  func main () {

      fmt.Println(c())
  }
#+END_SRC

Такой финт позволяет модифицировать error-возвращаемое значенеи функции.

** Panic/recover

Это механизм, позволяющий отлавливать ошибки и корректно завершать
функции, не допуская аварийной остановки всей программы. Обязательно
используется в связке с defer.


panic - это встроенная в язык функция, которая останавливает нормальый поток
выполнения и начинает паниковать. Она может быть вызвана напрямую
программистом или же рантаймом языка, если исполнение программы привело к
ошибке (например к попытке прочитать значение за границами массива).

Когда нормальное исполнение функции прерывается panic, то сначала
вызываются все отложенные вызовы - выражения, которые начинаются с
~defer~, а затем функция завершается.

recover - это встроенная в язык, позволяющая вернуть контроль над
паникующей горутиной. Может быть использована только внутри выражения
defer -  в противном случае просто вернет 0 и не произведет никакого
другого эффекта.

Если текущая подпрограмма паникует, вызов восстановления захватит
значение, заданное для паники, и возобновит нормальное выполнение.

Посмотрим на пример ниже.
Есть функция f и g. Функция f вызывается из main, а g вызывается из f с
параметром 0.

Что делает g? Она рекурсивно вызывает саму себя до тех пор, пока аргумент
не больше 3. На каждом вызове у нас кладется в список отложенных вызовов
печать значения аргумента.

Вот аргумент g стал больше 3. В этом случае сработала panic - ее заданное
значение - это строка со значением аргумента g.

Начинают исполняться отложенные вызовы, которые мы копили, пока
рекурсивно вызывали g. Мы помним, что отложенные вызовы исполняются в
порядке FIFO: т.е. при печати мы увидим строку с убывающим аргументом g,
а не с возрастающим.

После того, как все отложенные вызовы исполнились, g завершается и
возвращает "панику" вызвавшей ее функции - т.е. f. Теперь у нас начинает
паниковать f: ее нормальное исполнение останавливается и исполняется
отложенный вызов defer.
А внутри него у нас попытка вернться контроль над паникующей функцией: мы
вызываем recover. recover перехватывает заданное значение для паники - мы
помним, что это строка с аргументом g - после чего возобновляется
нормальное исполнение функции f и она завершается.

#+NAME: _panic_recover
#+BEGIN_SRC go :noweb yes :tangle panic_recover.go
  package main

  import "fmt"

  func main() {
      f()
      fmt.Println("Returned normally from f.")
  }

  func f() {
      defer func() {
          if r := recover(); r != nil {
              fmt.Println("Recovered in f", r)
          }
      }()
      fmt.Println("Calling g.")
      g(0)
      fmt.Println("Returned normally from g.")
  }

  func g(i int) {
      if i > 3 {
          fmt.Println("Panicking!")
          panic(fmt.Sprintf("%v", i))
      }
      defer fmt.Println("Defer in g", i)
      fmt.Println("Printing in g", i)
      g(i + 1)
  }
#+END_SRC

* ООП

* SOLID

* DDD (domain driven design)

* Материалы по go
Взгляд на го изнутри: планировщик горутин, работа с памятью, работа GC.
http://m0sth8.github.io/runtime-1/#13

* Интересные мысли из effective.go
