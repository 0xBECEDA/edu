* Интро
Шпаргалка по хэш таблицам.

* Источники
https://habr.com/ru/post/509220/
https://www.youtube.com/watch?v=rVr1y32fDI0
https://www.youtube.com/watch?v=xXaqBe78AfI

* Общее устройство хэш-таблиц

Хэш-таблица по факту представляет собой массив, где каждый элемент - это
пара ключ-значение. Доступ к массиву осуществляется по индексу за О(1).
А индексом элемента является ~хэш~ от ключа, который хранится в связке
ключ-значение в качестве элемента массива. Поэтому хэш-табица и называется ~хэш~-таблицей.

[TODO:gmm] Если хэш-таблицы такие быстрые с т.з. доступа и вставки
элементов, то зачем вообще использовать другие структуры данных?

Когда мы осуществляем поиск, удаление или вставку элемента, все что
нужно - это получить хэш от ключа. Затем использовав этот хэш как индекс
массива мы можем делать с элементом по этому индексу все, что захотим.

Есть только одна проблема: легко может случиться так, что на два разных
ключа будет получен один хэш. Есть два основных метода разрешения
коллизий:

- метод открытой адресации
- метод цепочек

** Метод открытой адресации

При методе открытой адресации если мы вставляем новый элемент в таблицу,
а хэш от его ключа такой же, как у дргого ключа - а это легко проверить,
потому что слот массива по заданному индексу окажется занят - то в этом
случае просто ищется ближайший свободный слот массива и данные
записываются в него.

[TODO:gmm] Как в этом случае искать элемент, если хэш больше нельзя
использовать как индекс в массиве?

В этом случае при поиске элемента нужно будет проверять, что
У этого решения есть ряд недостатков:

- кластеризация - когда у нас некоторые значения образуют кластеры
(т.е. идут один за другим в таблице), потому что хэш от их ключей был
одинаков и мы искали ближайший свободный слот

- возрастающая сложность вставки  - в худшем случае O(n), поскольку
  ближайший свободный слот может оказаться последним в таблице

** Метод цепочек

В этом случае элементы массива представляют собой односвязный список
пар ключ-значение.

В случае, если хэши у ключей совпадают, то мы создаем новую пару
ключ-значение и добавляем ее к списку таких пар, которые хранятся в
качестве элемента массива по данному хэшу (индексу).

Тогда поиск элемента в худшем случае будет иметь сложность O(n),
поскольку может оказаться, что искомый элемент - последний в списке.

* Самостоятельная реализация хэш-таблицы на го

Реализауем хэш-таблицу с помощью метода цепочек: элементами массива будут
списки, состоящие из структуры пара-значения и указателя на следующую
стрктуру. Если при добавлении значения в таблицу выяснится, что хэш от
ключа совпадает с хэшем от какого-то другого ключа, то мы просто добавим
новую ячейку в список, доступный по полученному хэшу.

Заведем структуру ячейки списка, выделим массив под таблицу и обозначим его
размер. Будем считать, в хэш-таблице мы будем хранить возраст и имя
человека, где возраст - это ключ.

Поэтому структура ячейки будет включать в себя три поля: возраст, имя и
указатель на следующую ячейку.

Так же обозначим размер таблицы в переменной ~table_cap~ и заведем слайс
под таблицу с заданной вместимостью. Слайс будет содержать в себе
указатели на ячейки.

UPD: Можно взять обычный массив, потому что расширять хэш-таблицу - это
всегда большая проблема, поэтому обычно они фиксированного размера.

#+NAME: _globals
#+BEGIN_SRC go :noweb yes :tangle hashmap.go
  package main

  import(
      "fmt"
  )

  type hash_map_cell struct {
      Age int
      Name string
      NextCell *hash_map_cell
  }

  var table_cap = 10
  var table = make( []*hash_map_cell, table_cap)

  <<_make_hash>>
#+END_SRC

Теперь разберемся с алгоритмом хэширования: превращая заданный ключ в
хэш, мы получаем индекс массива, по которому запишем новую пару
ключ-значение.

Самый простой вариант - это использовать остаток от деления ключа на
вместимость таблицы.

#+NAME: _make_hash
#+BEGIN_SRC go :noweb yes
  func hash_key(key int) int {
      return key % table_cap
  }

  <<_addValue>>
#+END_SRC


Теперь можно приступить к добавлению элементов. Для этого реализуем 2
функции: ~addValueToTable~ и ~addValueToList~. Чтоб добавить значение в
таблицу, нужно вызвать ~addValueToTable~, которая в свою очередь вызовет
~addValueToList~, если в этом возникнет необходимость.

Алгоритм крайне прост:
- хэшируем заданый ключ - получаем индекс слайса
- получаем содержимое ячейки слайса по индексу
- если содержимое ~nil~, то заводим новую ячейку, вписываем в нее ключ и
  значение, получаем указатель на ячейку и заносим его как содержимое
  ячейки слайса по уже известному индексу
- в противном случае вызываем ~addValueToList~, которая пройдется по
  списку, каждый раз сравнивая заданный ключ с текущим из ячейки. Если
  ключи совпадут, то значение ~Name~ текущей ячейки списка будет
  изменено. Если же функция дойдет до конца списка, то заведет новую
  ячейку, внесет в нее данные и свяжет ее с концом списка.

#+NAME: _addValue
#+BEGIN_SRC go :noweb yes
  // проходится по списку значений и либо добавляет ячейку,
  // либо изменяет значение ячейки, чей ключ соответствует заданному
  func addValueToList( list *hash_map_cell, key int, value string ) {

      if list.Age == key {
          list.Name = value
          return

      } else {
          if list.NextCell == nil {
              newCell := hash_map_cell{Age: key, Name: value, NextCell: nil}
              list.NextCell = &newCell
              return
          }
          addValueToList( list.NextCell, key, value )
      }
      return
  }

  // добавляет значение в таблицу
  // или изменяет уже существующее, если заданный ключ присутствует
  func addValueToTable(key int, value string) {
      indx := hash_key(key)
      hashCell := table[indx]

      if	hashCell == nil {
          newCell := hash_map_cell{Age: key, Name: value, NextCell: nil}
          table[indx] = &newCell
          return
      }

      addValueToList(hashCell, key, value)
      table[indx] = hashCell
      return
  }

  <<_getValue>>
#+END_SRC

Теперь реализуем поиск элемента в таблице.
Алгоритм очень похож на добавление элемента:
- хэшируем заданный ключ - получаем индекс в слайсе
- получаем содержимое ячейки слайса по индексу
- если это ~nil~, выводм сообщение об ошибке: значения явно нет
- в противном случае проходимся по списку значений до тех пор, пока либо не
  найдем искомое - тогда вернем его, либо не достигнем конца списка -
  тогда вернем сообщение об ошибке

#+NAME: _getValue
#+BEGIN_SRC go :noweb yes
  // ищет значение в списке
  func foundValueInList(list *hash_map_cell, key int) (string, int) {

      if list.Age == key {
          return list.Name, 0

      } else {
          if list.NextCell == nil {
              return "No value found \n", -1
          }
          return foundValueInList(list.NextCell, key)
      }
  }

  // ищет значение в таблице
  // возвращает значение или сообщение об ошибке
  func getValueFromTable(key int) (string, int)  {

      indx := hash_key(key)
      hashCell := table[indx]

      if hashCell == nil {
          return "No value found \n", -1
      }
      return foundValueInList(hashCell, key)
  }

  <<_deleteValue>>
#+END_SRC

Теперь реализуем удаление элемента. Алгоритм опять тот же самый, только с
небольшими модификациями.

- хэшируем ключ и получаем соержимое ячейки слайса
- если значение = nil, выводим сообщение об ошибке (нельзя удалить то,
  чего итак нет)
- в противном случае проверяем, не является ли искомое значение первым в
  списке значений
- если является, берем указатель на следующий элемент
  списка и заносим его в ячейку слайса по известному индексу.
- иначе проходимся по списку, проверяя, является ли значение ~следующей~
  ячейки от текущей ячейки искомым: если является, то мы берем указатель на следующую за
  ней ячейку списка и устанавливаем его в качестве указателя на следующую
  ячейку от текущей ячейки. Таким образом мы просто меняем один указатель
  на другой, "вырезая" ненужную нам ячейку

#+NAME: _deleteValue
#+BEGIN_SRC go :noweb yes
  // удаляет ячейку из списка
  func deleteValueFromList(list *hash_map_cell, key int) (string, int) {

      if list == nil {
          return "No such value \n", -1

      } else if list.NextCell.Age == key {
          list.NextCell = list.NextCell.NextCell
          return "Value successfully deleted \n ", 0
      }
      return deleteValueFromList(list.NextCell, key)
  }

  // удаляет значение из мапы по ключу
  func deleteValue(key int) (string, int) {

      indx := hash_key(key)
      hashCell := table[indx]

      if hashCell == nil {
          return "No such value \n", -1

      } else if hashCell.Age == key {
          table[indx] = hashCell.NextCell
          return "Value successfully deleted \n ", 0
      }
      return deleteValueFromList(hashCell, key)
  }

  <<_main>>
#+END_SRC

Тестируем функционал:
#+NAME: _main
#+BEGIN_SRC go :noweb yes
  func main () {
      // тестируем добавление значений, хэш ключей которых
      // получается одинаковым
      addValueToTable(32, "Pushkin" )
      val, _ := getValueFromTable(32)
      fmt.Printf(" getValueFromTable: key is %d, value is %s \n", 32, val)

      addValueToTable(42, "Leonid" )
      val2, _ := getValueFromTable(42)
      fmt.Printf(" getValueFromTable: key is %d, value is %s \n", 42, val2)

      addValueToTable(12, "Ivan" )
      val3, _ := getValueFromTable(12)
      fmt.Printf(" getValueFromTable: key is %d, value is %s \n", 12, val3)

      // добавляем значение с ключом, хэш которого будет отличным от предыдущих
      addValueToTable(10, "Stefan" )
      val4, _ := getValueFromTable(10)
      fmt.Printf(" getValueFromTable: key is %d, value is %s \n", 10, val4)

      // удаляем значение из середины цепочки
      msg, _ := deleteValue(42)
      fmt.Printf(" deleteValue: key is %d, msg: %s \n", 42, msg)

      // проверяем, что значение действительно удалено
      val2, _ = getValueFromTable(42)
      fmt.Printf(" getValueFromTable: key is %d, value is %s \n", 42, val2)
  }
#+END_SRC

Скомпилить: go build hashmap.go
Запустить: ./hashmap
