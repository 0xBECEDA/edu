* Интро
Инфа по слабым ссылкам

* Слабые ссылки

С т.з. GC объект в памяти должен существовать до тех пор, пока к нему
можно обратиться, т.е. пока на него есть ссылка. В случае если
обратиться к объекту более невозможно, GC очищает память и объект
перестает существовать.

В случае со слабой ссылкой GC может удалить объект, на который она
ссылается, при условии, что на него не ссылается никакая обычная ссылка -
в контаксте слабых ссылок обычные ссылки называют сильными.

Когда объект удаляется, все слабые ссылки, указывающие на него,
обнуляются.

* Проблемы, которые решают слабые ссылки

- "забытые" ссылки

Допустим, программист сделал несколько ссылок на один и тот же объект и
сохранил их в нескольких местах и при прекращении работы с объектам не
удалил их, т.е. мы получили некоторое количество "забытых" ссылок. В
результате GC не удаляет объекты, на которые ссылаются эти ссылки, и мы
получаем утечку памяти.

- зацикливание ссылок

Допустим есть некоторый объект, который прямо или косвенно ссылается на
себя же. В таком случае если GC использует подсчет ссылок на объект как основной
способ определить, удалять объект или нет, то объект никогда не будет
удален, поскольку на него всегда будет указывать минимум 1 ссылка.

- использование объектов (или ссылок них) в качестве ключей

Допустим, есть некоторая хэш-таблица, где ключами выступают объекты (или
ссылки на объекты), а значения - это некая информация об этих объектах,
например, список их свойств, который даже может быть пустым. В случае
если ссылки на объекты - это обычные ссылки, то GC никогда не удалит
их. А вот если ключ - это слабая ссылка, то удаление становится возможным

* Недостатки слабых ссылок

- попытка обращения к уже освобожденной памяти по несуществующей ссылке

В какой-то момент не будет сильной ссылки на объект, на который ссылается
слабая ссылка. В результате GC очищает объект, потом прогер пытается
воспользоваться уже несуществующей слабой ссылкой на несуществующий
объект и получает ошибку.

- бОльшая нагрузка на GC

Возможно, есть что-то еще.

* Эфемерон

Это симбиоз ассоциативности и слабой ссылки.
Как уже описывалось выше, у нас может быть ситуация, когда нужно
построить ассоциативный массив, где ключ - это объект (или ссылка на него), а значение -
свойства объекта. Если ключ - это сильная ссылка и/или если значение
объекта косвенно или прямо ссылается на сам объект, то такой объект
никогда не будет очищен GC.

Поэтому нужен эфемерон.
В общем случае эфемерон - поддерживает ссылки на два объекта: ключ и
значение. Пока ключ достижим по сильным ссылкам, ни ключ, ни значение не
удаляются.  Если ключ перестаёт быть достижим, то обе ссылки обнуляются, и ключ
освобождается.

Вся соль в том, что если "значение" каким-то образом ссылается на "ключ",
то GC это просто игнорирует и все равно может удалить ключ, если на него
нет сильных ссылок. С т.з GC эфемерон связан слабой ссылкой с ключом, но
при этом ключ со значением связан сильной ссылкой.

В разных языка это реализовано по-разному.
Например, вот так эфемероны реализуеются в SmallTalk
http://www.smalltalk.ru/2005/04/vw-ephemeron.html

* Слабые ссылки в разных языках программирования
** Java

Джава реализует аж три вида слабых ссылок:
- мягкие - объект, достижимый по только мягким ссылкам, будет освобожден
  в случае, если в куче осталось мало места

- слабые - при освобождении памяти, ссылки обнуляются до вызова
  финализатора.

  ( Финализатор - это процедура, которая вызывается в
  промежутке времени, когда объект уже помечен как недостижмый, но память
  еще не очищена. Финализатор может обеспечивать проверку объекта перед
  очисткой, вызывать внешнюю функцию для очистки памяти (например, если
  объект java для эффективности использовал сишную malloc, то теперь надо
  вызывать сишную же free для освобождения памяти) и т.д.
  см сюда
  https://ru.wikipedia.org/wiki/%D0%A4%D0%B8%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%82%D0%BE%D1%80)

- фантомные - при освобождении памяти, ссылки обнуляются непосредственно
  перед освобождением памяти.

** Haskell

Один из немногих языков, использующий эфемероны. См. в раздел ~эфемерон~.

Про другие языки можно посмотреть вот тут
https://habr.com/ru/post/163679/
