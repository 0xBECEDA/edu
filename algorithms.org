* Интро
Освоение алгоритмов и построения деревьев.

* Реализация бинарного дерева
Реализация алгорима по построению бинарного дерева.

** На лиспе

#+NAME bst_lisp
#+BEGIN_SRC lisp :tangle lisp_alg.lisp
  ;; структура ноды
  (defstruct (node)
    elt (l nil) (r nil))

  ;; вставка в дерево
  (defun insert-bst (tree obj)
    (if (null tree)
        (make-node :elt obj)
        (let ((elt (node-elt tree)))
          (cond (( > obj elt)
                 (if (null (node-r tree))
                     (setf (node-r tree) (make-node :elt obj))
                     (insert-bst (node-r tree) obj)))
                (( < obj elt)
                 (if (null (node-l tree))
                     (setf (node-l tree) (make-node :elt obj))
                     (insert-bst (node-l tree) obj)))
                (t tree)))))

  ;; создание дерева
  (defun make-bst (lst)
    (defun make-bst-rec (bst-tree lst)
      (if (null lst)
          bst-tree
          (progn
            (insert-bst bst-tree (car lst))
            (make-bst-rec bst-tree (cdr lst)))))
    (make-bst-rec (insert-bst nil (car lst)) (cdr lst)))

  ;; тесты
  (make-bst '(1 2 3 4 5 6))
  (make-bst '(4 7 20 5 3 8 2 9 2))

#+END_SRC

** На си

#+NAME: bst_c
#+BEGIN_SRC c :tangle bst.c
  #include <stdio.h>
  #include <stdlib.h>

  struct node {
      int elt;
      struct node * left;
      struct node * right;
  };


  int print_space ( int space ) {
      for( int i = 0; i < space; i++ ) {
          printf(" ");
      }
  }

  int print_string_with_spaces (char string[], int space ) {
      print_space ( space );
      printf("%s", string );
  }

  int print_bst_tree_rec ( struct node * tree, int space  ) {

      if ( NULL == tree ) {
          printf(" nil \n");
          return 0;
      }

      print_space ( 2 );
      printf("*NODE*: %d \n", tree->elt);

      print_string_with_spaces( "r:", space);
      print_bst_tree_rec ( tree->right, space + 5);

      print_string_with_spaces( "l:", space);
      print_bst_tree_rec ( tree->left, space + 5);
  }

  int print_bst_tree ( struct node * tree ) {
      print_bst_tree_rec ( tree, 2 );
  }

  struct node* insert_bst ( struct node * tree, int obj ) {

      if ( NULL == tree ) {
          struct node* new_node = (struct node*)malloc(sizeof( struct node ) );
          new_node->elt = obj;
          return new_node;

      } else if ( obj > tree->elt) {

          if ( tree->right == NULL ) {
              struct node* new_node = (struct node*)malloc(sizeof( struct node ) );
              new_node->elt = obj;
              tree->right = new_node;
              return tree;
          }
          insert_bst ( tree->right, obj );

      } else if ( obj < tree->elt) {

          if ( tree->left == NULL ) {
              struct node* new_node = (struct node*)malloc(sizeof( struct node ) );
              new_node->elt = obj;
              tree->left = new_node;
              return tree;
          }
          insert_bst ( tree->left, obj );
      } else {
          return tree;
      }
  }

  struct node* make_bst ( int numbers[], int len ) {
      struct node* tree = insert_bst( NULL, numbers[0] );

      for (int i = 1; i < len; i++ ) {
          insert_bst( tree,  numbers[i]);
      }
      return tree;
  }

  int main () {
      int numbers[10] = {5, 9, 0, 1, 6, 10, 5, 3, 2, 8};
      struct node* tree = make_bst( numbers, 10 );
      print_bst_tree ( tree );
  }

#+END_SRC

** На го

#+NAME: bst_go
#+BEGIN_SRC go :tangle bst_go.go
  package main

  import ( "fmt" )

  type node struct {
      elt int
      left *node
      right *node
  }

  func printSpace( space int ) {
      for i := 0; i < space; i++ {
          fmt.Printf(" ")
      }
  }

  func printStringWithSpace( space int, msg string ) {
      printSpace( space )
      fmt.Printf("%s", msg)
  }

  func printTree ( tree *node) {
      printTreeRec ( tree, 1)
  }

  func printTreeRec ( tree *node, space int ) {

      if tree == nil {
          fmt.Printf("nil \n")

      } else {
          printSpace(1)
          fmt.Printf("*NODE*: %d \n", tree.elt)

          printStringWithSpace( space, "r: ")
          printTreeRec ( tree.right, space + 5 )

          printStringWithSpace( space, "l: ")
          printTreeRec ( tree.left, space + 5 )
      }
  }


  func insertBst( tree *node, obj int ) *node {
      if tree == nil {
          newTree := node{ elt: obj }
          return &newTree

      } else if ( obj > tree.elt ) {

          if ( tree.right == nil ) {
              newNode := node{ elt: obj }
              tree.right = &newNode
              return tree
          } else {
              insertBst( tree.right, obj )
          }
      } else if ( obj < tree.elt ) {

          if ( tree.left == nil ) {
              newNode := node{ elt: obj }
              tree.left = &newNode
              return tree
          } else {
              insertBst( tree.left, obj )
          }
      }
      return tree
  }

  func makeBst ( numbers [10]int ) *node {
      tree := insertBst( nil, numbers[0] )

      for i := range numbers {
          insertBst( tree, numbers[i] )
      }
      return tree
  }

  func main () {
      numbers := [10]int{4, 6, 1, 0, 2, 3, 3, 8, 10, 5}
      printTree( makeBst( numbers ) )
  }

#+END_SRC

* Поиск в глубину
** Описание алгоритма

Это алгоритм позволяет в любом связном простом графе найти его дерево.
- берем первую вершину
- находим первую смежную с ней, которая еще не включена в наше искомое
  дерево
- занимаем ее, ищем ближайшую вершину, смежную с ней и т.д.

Так до тех пор, пока не останется смежных вершин у какой-то вершины на
текущем шаге рекурсии. Тогда возвращаемся на предыдущий шаг рекурсии, и
ищем еще одну незанятую вершину и обходим это поддерево - при этом
вершины, которые мы обошли (и зашли в тупик) никуда из искомого дерева не
деваются. Наша цель - просто обойти весь граф таким образом, чтоб
избавиться от циклов - т.е. ни одна смежная вершина не должна быть уже
частью дерева, тогда мы можем включить ее в дерево.

Алгоритм заканчивает работу, когда все необойденные вершины кончаются.

** Реализация агоритма на циклическом графе

Сначала просто реализуем поиск в глубину на каком-то графе.
Сделаем это на 3х языках: с++, go и лисп. Начнем с лиспа, как с наиболее
известного языка.

Самое главное, нужно знать, не образует ли дерево, полученное в
результате поиска, цикл.

Сделать это просто: если две вершины нового ребра уже связаны друг с
другом каким-то путем в графе, то добавление этого ребра создаст цикл.

Предположим, есть список ребер (0 1) (1 3) (3 4) (4 2).  Мы хотим
добавить ребро (4 1). Чтоб определить, создаст ли это ребро цикл, нужно
определить, являются ли вершины 4 и 1 связными уже - т.е. есть ли между
ними какой-то путь.

Берем вершину 4. В списке ребер ищем все инцидентные ей ребра - они
должны выключать эту вершину. Если таковые есть, вытаскиваем вершины из
них и ищем инцидентные им ребра и т.д до тех пор, пока не найдем ребро,
инцидентное 1 или список не кончится.

#+BEGIN_SRC lisp
  ;; ищет все ребра, инцидентные заданной вершине
  (defun find-incident-edges (top list-of-edges)
    (if ( null list-of-edges)
        '()
        (if (member top (car list-of-edges))
            (cons  (car list-of-edges)
                   (find-incident-edges top (cdr list-of-edges)))
            (find-incident-edges top (cdr list-of-edges)))))

  ;; (find-incident-edges 4 '((1 2) (3 4) (4 5) (5 6) (1 4)))

  ;; возвращает вершину в ребре, отличную от заданной, при условии, что эта вершина
  ;; не числится как "исследованная"
  (defun get-second-top (top edge list-of-researched-tops)
    (if ( = top (car edge))
        (if (member (cadr edge) list-of-researched-tops)
            nil
            (cadr edge))
        (if (member (car edge) list-of-researched-tops)
            nil
            (car edge))))

  ;; ищет первую неисследованную вершину, среди концевых ребер вершины, инцидентных
  ;; заданной
  (defun get-unserched-top (top list-of-researched-tops list-of-incident-edges)
    (if (null list-of-incident-edges)
        nil
        (let ((unserched-top (get-second-top top (car list-of-incident-edges)
                                             list-of-researched-tops)))
          (if (null unserched-top)
              (get-unserched-top top list-of-researched-tops
                                 (cdr list-of-incident-edges))
              unserched-top))))

  ;; определяет, есть ли какой-то путь между двумя заданными вершинами
  ;; принимает 2 вершины и список ребер, возвращает булево значение
  (defun have-path? (top-begin top-end list-of-edges)
    (have-path-rec top-begin top-end list-of-edges '()))

  (defun have-path-rec (top-begin top-end list-of-edges list-of-researched-tops)
    (if (null list-of-edges)
        nil
        (let ((list-of-incident-edges
               (find-incident-edges top-begin list-of-edges)))
          (if (find-incident-edges top-end list-of-incident-edges)
              t
              (do ((i (length list-of-incident-edges) (decf i)))
                  ((= i 0) nil)
                (let ((new-top (get-unserched-top
                                top-begin list-of-researched-tops
                                list-of-incident-edges)))
                  (if (null new-top)
                      nil
                      (if (have-path-rec new-top top-end list-of-edges
                                      (cons top-begin
                                            list-of-researched-tops))
                          (return-from have-path-rec t)
                          (setf list-of-incident-edges
                                (cdr list-of-incident-edges))))))))))



  (have-path? 4 3 '((1 2) (3 4) (4 5) (5 6) (1 4)))
  (have-path? 4 6 '((1 2) (3 4) (4 5) (5 6) (1 4)))
  (have-path? 6 3 '((1 2) (3 4) (4 5) (5 6) (1 4)))
  (have-path? 0 3 '((1 2) (3 4) (4 5) (5 6) (1 4)))
  (have-path? 4 7 '((1 2) (3 4) (4 5) (5 6) (1 4) (2 7)))
  (have-path? 1 8 '((1 2) (3 4) (4 5) (5 6) (1 4) (2 7) (9 8)))
#+END_SRC

Мы предполагаем, что граф будет задаваться как список ребер, где каждый
подсписок - это 2 концевые вершины ребра.
Пройденные ребра надо запоминать - это и будет дерево, образованное от
поиска в глубину. Прежде чем добавить новое ребро, проверяем, не создаст
ли это цикл. Если да, то не добавляем ребро в список ребер.

Мы предполагаем, что граф размеченный - т.е. у вершин есть некоторый
порядок. Предположим, есть вершина 2 и ей инцидентны вершины 4
и 7. Сначала пойдем по ребру, соединяющему 2 и 4, и только когда обойдем
это поддерево, то пойдем по ребру (2 7), если в этом будет
необходимость.

На каждом шаге рекурсии:
- берем вершину
- ищем все инцидентные ей
- выбираем ту, что соединяет текущую вершину и наиболее близкую к ней по
  порядку
- заносим ребро, соединяющее их, в список сохраненных ребер
- идем к новой вершине и проверяем все вершины, инцидентные ей и т.д.
- повторяем до тех пор, пока не уперлись в тупик - нет инцидентных вершин
  или они уже все обойдены.

#+BEGIN_SRC lisp
  (defun get-other-top (top edge)
    (if (= top (car edge))
        (cadr edge)
        (car edge)))

  ;; ищет "ближайшее" по порядку вершин ребро
  (defun find-nearest-edge (top edge list-of-incident-edges)
    (if (null list-of-incident-edges)
        edge
        (if (> (get-other-top top edge)
               (get-other-top top (car list-of-incident-edges)))
            (find-nearest-edge top (car list-of-incident-edges)
                               (cdr list-of-incident-edges))
            (find-nearest-edge top edge
                               (cdr list-of-incident-edges)))))


  ;; ищет следующее доступное для прохода ребро
  (defun find-next-edge (top list-of-incident-edges path-in-depth)
    (if (null list-of-incident-edges)
        nil
        (let ((nearest-edge (find-nearest-edge top
                                               (car list-of-incident-edges)
                                               (cdr list-of-incident-edges))))
          (if (have-path? (car nearest-edge) (cadr nearest-edge) path-in-depth)
              (find-next-edge top
                              (remove nearest-edge list-of-incident-edges :test #'equal)
                              path-in-depth)
              nearest-edge))))


  ;; (find-next-edge 4 '((3 4) (1 4) (4 5)) '())
  ;; (find-next-edge 4 '((3 4) (1 4) (4 5)) '((4 3) (3 1)))
  ;; (find-next-edge 4 '((3 4) (1 4)) '((4 3) (3 1)))

  (defun search-in-depth-rec (top list-of-edges path-in-depth)
    (if (null list-of-edges)
        path-in-depth
        (let ((list-of-incident-edges
               (find-incident-edges top list-of-edges)))
          (do ((i (length list-of-incident-edges) (decf i)))
              ((= i 0) path-in-depth)
            (let ((edge (find-next-edge top list-of-incident-edges path-in-depth)))
              (if (null edge)
                  (return path-in-depth)
                  (progn
                    (setf list-of-incident-edges
                          (remove edge list-of-incident-edges :test #'equal)
                          path-in-depth (cons edge path-in-depth)
                          list-of-edges (remove edge list-of-edges :test #'equal))
                    (let ((new-path (search-in-depth-rec (get-other-top top edge)
                                                         list-of-edges path-in-depth)))
                      (setf path-in-depth new-path)))))))))

  (defparameter *test-graph* '((0 3) (3 1) (1 10) (10 0) (1 2) (2 8) (8 12)
                               (12 5) (6 11) (5 11) (4 6) (7 9) (4 7) (4 8)))

  (defparameter *test-graph2* '((1 2) (1 4) (2 7) (2 4) (4 3) (4 5) (5 6)))

  (search-in-depth-rec 1 *test-graph2* '())
  (search-in-depth-rec 0 *test-graph* '())
#+END_SRC

** Поиск в глубину на бинарном дереве

*** На лиспе

Сначала строим бинарное дерево, используя уже известные процедуры:

#+BEGIN_SRC lisp
  (setf test-tree (make-bst '(4 7 20 5 3 8 2 9 1 0 32 14 6)))
#+END_SRC

Поскольку известно, что все деревья ациклические, то не надо проверять,
не образует ли маршрут обходов циклов. Так же у бинарного дерева максимум
2 ветки всегда, что тоже сильно облегчает жизнь.

Процедура по обходу принимает дерево, а возвращает список вершин в том
порядке, в котором она его обошла.


#+NAME dfs_lisp
#+BEGIN_SRC lisp :tangle lisp_alg.lisp
  (defun dfs-rec (bst-tree list-of-nodes)
    (if (null bst-tree)
        list-of-nodes
        (progn
          (setf list-of-nodes (append list-of-nodes (list (node-elt bst-tree))
                                      (dfs-rec (node-r bst-tree) '())
                                      (dfs-rec (node-l bst-tree) '())))
          list-of-nodes)))


  (defun dfs (tree)
    (dfs-rec tree '()))

  (dfs test-tree '())
#+END_SRC

*** На си

Делаем аналогично на си.

#+NAME dfs_c
#+BEGIN_SRC c :tangle dfs.c
  #include <stdio.h>
  #include <stdlib.h>

  struct node {
      int elt;
      struct node * left;
      struct node * right;
  };


  /* вставляет элемент в дерево */
  struct node* insert_bst ( struct node * tree, int obj ) {

      if ( NULL == tree ) {
          struct node* new_node = (struct node*)malloc(sizeof( struct node ) );
          new_node->elt = obj;
          return new_node;

      } else if ( obj > tree->elt) {

          if ( tree->right == NULL ) {
              struct node* new_node = (struct node*)malloc(sizeof( struct node ) );
              new_node->elt = obj;
              tree->right = new_node;
              return tree;
          }
          insert_bst ( tree->right, obj );

      } else if ( obj < tree->elt) {

          if ( tree->left == NULL ) {
              struct node* new_node = (struct node*)malloc(sizeof( struct node ) );
              new_node->elt = obj;
              tree->left = new_node;
              return tree;
          }
          insert_bst ( tree->left, obj );
      } else {
          return tree;
      }
  }

  /* строит дерево */
  struct node* make_bst ( int numbers[], int len ) {
      struct node* tree = insert_bst( NULL, numbers[0] );

      for (int i = 1; i < len; i++ ) {
          insert_bst( tree,  numbers[i]);
      }
      return tree;
  }

  /* ищет путь в глубину */
  int* dfs (struct node* tree, int len ) {
      int *path  =  (int*)malloc( (sizeof( int ) ) * len);
      int *path_duble = path;

      int dfs_rec ( struct node* tree ) {
          if ( NULL == tree ) {
              return 0;

          } else {
              ,*path = tree->elt;
              path++;
              dfs_rec( tree->right );
              dfs_rec( tree->left );
          }
      }
      dfs_rec(tree);
      return path_duble;
  }

  int main () {
      int numbers[13] = {4, 7, 20, 5, 3, 8, 2, 9, 1, 0, 32, 14, 6,};
      struct node* tree = make_bst( numbers, 13 );
      int* dfs_path = dfs( tree, 13 );

      for (int i = 0; i < 13; i++ ) {
          printf("%d ",  *dfs_path);
          dfs_path++;
      }
      printf("\n");
  }
#+END_SRC

*** На го

#+NAME dfs_go
#+BEGIN_SRC go :tangle dfs_go.go
  package main

  import ("fmt")

  type node struct {
      elt int
      left *node
      right *node
  }

  func insertBst( tree *node, obj int ) *node {
      if tree == nil {
          newTree := node{ elt: obj }
          return &newTree

      } else if ( obj > tree.elt ) {

          if ( tree.right == nil ) {
              newNode := node{ elt: obj }
              tree.right = &newNode
              return tree
          } else {
              insertBst( tree.right, obj )
          }
      } else if ( obj < tree.elt ) {

          if ( tree.left == nil ) {
              newNode := node{ elt: obj }
              tree.left = &newNode
              return tree
          } else {
              insertBst( tree.left, obj )
          }
      }
      return tree
  }

  func makeBst ( numbers [13]int ) *node {
      tree := insertBst( nil, numbers[0] )

      for i := range numbers {
          insertBst( tree, numbers[i] )
      }
      return tree
  }

  func dfs_rec( tree *node, path []int, indx int) int {
      if nil == tree {
          return indx

      } else {
          path[indx] = tree.elt
          indx++
          indx = dfs_rec( tree.right, path, indx )
          indx = dfs_rec( tree.left, path, indx )
      }
      return indx
  }

  func dfs( tree *node, len int ) []int {
      path := make([]int, len)
      dfs_rec(tree, path, 0)
      return path
  }

  func main () {
      numbers := [13]int{4, 7, 20, 5, 3, 8, 2, 9, 1, 0, 32, 14, 6}
      tree := makeBst( numbers )
      path := dfs(tree, 13)

      for i := range path {
          fmt.Printf("%d ", path[i])
      }
      fmt.Printf("\n")
  }
#+END_SRC
* Поиск в ширину

Это алгоритм, который из любого графа позволяет построить такое его
остовное дерево, в котором расстояние от корня до любой вершины такое
же, как в исходном графе. Это его отличие от поиска в глубину.

Обход в ширину означает, что мы движемся от корня до листьев графа, но
сначала обходим все узлы на текущем "уровне" дерева, потом спускаемся на
один уровень ниже и обходим все там, и т.д, пока не дойдем до листьев.

** Обход бинарного берева

*** На лиспе

Создаем бинарное дерево.
#+BEGIN_SRC lisp
  (setf test-tree (make-bst '(4 7 20 5 3 8 2 9 1 0 32 14 6)))
#+END_SRC

Процедура принимает на вход дерева, а возвращает список вершин в том
порядке, в котором она его обошла - т.е. как обойти вершины поиском в
ширину.
#+NAME bfs
#+BEGIN_SRC lisp :tangle lisp_alg.lisp
  ;; создает очередь
  (defun make-queue () (cons nil nil))

  ;; добавляет объект в очередь
  (defun enqueue (obj q)
    (if (null (car q))
        (setf (cdr q) (setf (car q) (list obj)))
        (setf (cdr (cdr q)) (list obj)
              (cdr q) (cdr (cdr q))))
    (car q))

  ;; берет объект из очереди
  (defun dequeue (q)
    (pop (car q)))

  ;; проверяет, пустая ли очередь
  (defun null-queue (queue)
    (and (null (car queue))
         (null (cdr queue))))

  ;; осуществляет посик в ширину
  (defun bfs (tree lst queue)
    (if (null tree)
        lst
        (progn
          (setf lst (append lst (list (node-elt tree))))
          (cond ((and (node-r tree) (node-l tree))
                 (progn
                   (enqueue (node-l tree) queue)
                   (enqueue (node-r tree) queue)
                   (bfs (dequeue queue) lst queue)))
                ((node-r tree)
                 (progn
                   (enqueue (node-r tree) queue)
                   (bfs (dequeue queue) lst queue)))
                ((node-l tree)
                 (progn
                   (enqueue (node-l tree) queue)
                   (bfs (dequeue queue) lst queue)))
                ((null-queue queue)
                 lst)
                (t (bfs (dequeue queue) lst queue))))))

  (bfs test-tree '() (make-queue))

#+END_SRC

*** На си

На ми можно реализовать очередь с помощью односвязного списка с двумя
указателями: один указывает на первый элемент, второй - на следующую
свободную ячейку в очереди.
Очередь пуста, если оба указателя указывают на одну и ту же ячейку.

Добавление элемента в очередь:
- записать элемент в свободную ячейку, на которую указывает второй указатель
- создать новую пустую ячейку
- сдвинуть хвостовой указатель, чтоб указывал на нее

Взятие элемента из очереди:
- считать элемент по головному указателю очереди
- сдвинуть головной указатель на следующую ячейку


#+NAME: queue_bfs
#+BEGIN_SRC c :noweb yes
  struct queue_elt {
      struct node * elt;
      struct queue_elt * next_elt;
  };

  struct queue_elt * begin_queue;
  struct queue_elt * end_queue;


  void init_queue() {
      begin_queue = (struct queue_elt*)malloc( sizeof( struct queue_elt ) );
      end_queue = begin_queue;
  }

  int empty_queue_predicat() {
      if ( begin_queue == end_queue ) {
          return 1;
      }
      return 0;
  }

  struct queue_elt * pop_elt() {
      struct queue_elt * elt = begin_queue;
      begin_queue = begin_queue->next_elt;
      return elt;
  }

  void push_elt( struct node * elt ) {
      end_queue->elt = elt;
      struct queue_elt* empty_queue_elt = (struct queue_elt*)malloc( sizeof( struct queue_elt ) );
      end_queue->next_elt = empty_queue_elt;
      end_queue = empty_queue_elt;
  }
#+END_SRC


#+NAME bfs_c
#+BEGIN_SRC c :noweb yes :tangle bfs.c
  #include <stdio.h>
  #include <stdlib.h>

  struct node {
      int elt;
      struct node * left;
      struct node * right;
  };

  <<queue_bfs>>

  struct node* insert_bst ( struct node * tree, int obj ) {

      if ( NULL == tree ) {
          struct node* new_node = (struct node*)malloc(sizeof( struct node ) );
          new_node->elt = obj;
          return new_node;

      } else if ( obj > tree->elt) {

          if ( tree->right == NULL ) {
              struct node* new_node = (struct node*)malloc(sizeof( struct node ) );
              new_node->elt = obj;
              tree->right = new_node;
              return tree;
          }
          insert_bst ( tree->right, obj );

      } else if ( obj < tree->elt) {

          if ( tree->left == NULL ) {
              struct node* new_node = (struct node*)malloc(sizeof( struct node ) );
              new_node->elt = obj;
              tree->left = new_node;
              return tree;
          }
          insert_bst ( tree->left, obj );
      } else {
          return tree;
      }
  }

  struct node* make_bst ( int numbers[], int len ) {
      struct node* tree = insert_bst( NULL, numbers[0] );

      for (int i = 1; i < len; i++ ) {
          insert_bst( tree,  numbers[i]);
      }
      return tree;
  }

  int*  bfs( struct node* tree, int len ) {
      int *path  =  (int*)malloc( (sizeof( int ) ) * len);
      int *path_begin = path;

      int bfs_rec ( struct node* tree ) {

          if( NULL == tree ) {
              return 0;
          }
          ,*path = tree->elt;
          path++;
          if ( NULL != tree->left && NULL != tree->right ) {
              push_elt(tree->left);
              push_elt(tree->right);
              struct queue_elt* next_node = pop_elt();
              bfs_rec ( next_node->elt );

          } else if ( NULL != tree->left ) {
              push_elt(tree->left);
              struct queue_elt* next_node = pop_elt();
              bfs_rec ( next_node->elt );

          } else if ( NULL != tree->right ) {
              push_elt(tree->right);
              struct queue_elt* next_node = pop_elt();
              bfs_rec ( next_node->elt );

          } else if ( empty_queue_predicat () == 1 ) {
              return 0;

          } else {
              struct queue_elt* next_node = pop_elt();
              bfs_rec ( next_node->elt );
          }
      }

      init_queue();
      bfs_rec ( tree );
      return path_begin;
  }

  int main () {
      int len = 10;
      int numbers[10] = {5, 9, 0, 1, 6, 10, 7, 3, 2, 8};
      struct node* tree = make_bst( numbers, len );
      int * elts = bfs( tree, len );

      for ( int i = 0; i < len; i++ ) {
          printf("%d ", *elts);
          elts++;
      }
      printf("\n");
  }
#+END_SRC

*** На го

Аналогичным образом реализуем поиск в ширину на go. Только это будет еще
проще, поскольку в го есть каналы, которые можно использовать вместо
очередей. Только используем неблокирующую запись/чтение.

#+NAME: bfs_go
#+BEGIN_SRC go :noweb yes :tangle bfs_go.go
  package main

  import ("fmt")

  type node struct {
      elt int
      left *node
      right *node
  }

  func insertBst( tree *node, obj int ) *node {
      if tree == nil {
          newTree := node{ elt: obj }
          return &newTree

      } else if ( obj > tree.elt ) {

          if ( tree.right == nil ) {
              newNode := node{ elt: obj }
              tree.right = &newNode
              return tree
          } else {
              insertBst( tree.right, obj )
          }
      } else if ( obj < tree.elt ) {

          if ( tree.left == nil ) {
              newNode := node{ elt: obj }
              tree.left = &newNode
              return tree
          } else {
              insertBst( tree.left, obj )
          }
      }
      return tree
  }

  func makeBst ( numbers [13]int ) *node {
      tree := insertBst( nil, numbers[0] )

      for i := range numbers {
          insertBst( tree, numbers[i] )
      }
      return tree
  }

  func bfs_rec ( tree *node, ch chan *node, path []int, indx int ) int {
      if tree == nil {
          return indx;

      } else {
          path[indx] = tree.elt
          indx++

          if tree.right != nil && tree.left != nil {
              ch <- tree.left
              ch <- tree.right
              new_node := <- ch
              bfs_rec( new_node, ch, path, indx )

          } else if tree.right != nil {
              ch <- tree.right
              new_node := <- ch
              bfs_rec( new_node, ch, path, indx )

          } else if tree.left != nil {
              ch <- tree.left
              new_node := <- ch
              bfs_rec( new_node, ch, path, indx )

          } else {
              select {
              case new_node := <- ch:
                  bfs_rec( new_node, ch, path, indx )

              default:
                  return indx;

              }
          }
      }
      return indx;
  }

  func bfs ( tree *node, len int ) []int  {
      path := make([]int, len)
      ch := make( chan *node,100 )
      bfs_rec( tree , ch, path, 0 )
      return path
  }

  func main () {
      numbers := [13]int{4, 7, 20, 5, 3, 8, 2, 9, 1, 0, 32, 14, 6}
      tree := makeBst( numbers )
      path := bfs( tree, 13 )
      for i := range path {
          fmt.Printf("%d ", path[i])
      }
      fmt.Printf("\n")
  }
#+END_SRC

* Красно-черное дерево

Двоичное дерево поиска, в котором баланс осуществляется на основе "цвета"
узла дерева, который принимает только два значения: "красный" (англ. red)
и "чёрный"

Свойства:
- Каждый узел промаркирован красным или чёрным цветом (помимо того, что
  содержат значения)
- Корень и конечные узлы (листья) дерева — чёрные
- У черных узлов могут быть дети как черные, так и красные
- У красных узлов ети могут быть только красные
- Все простые пути из любого узла x до листьев содержат одинаковое(!)
  количество чёрных узлов

** Алгоритм вставки в красно-черное дерево

Ищем лист для вставки как при обычном бинарном дереве.  Помним, что во
всех листах у нас nil и они окрашены в черный цвет.
Находим лист, вписываем в него новый элемент. Окрашиваем полученный узел
в красный (!) - потому что теперь этот лист становится узлом, у которого
должны быть обязательно черные потомки.
Дальше смотрим, если родительский узел нашего свеженького узла - черный,
то все отлично, дерево перебалансировать не надо. Но вот если он
красный - у нас накладка, потому что у красного узла родитель может быть
только черным. Тогда дерево придется перебалансировать - т.е. перекрасить
узлы так, чтоб соблюсти все свойства.

Так возникает вопрос: зачем нам переколбашивать дерево, если можно просто
окрасить свежий узел так, чтоб его цвет не противоречил правилам вместо
того, чтоб окрашивать его строго в красный?

Ответ: красно-черное дерево обязательно сбалансированное - поэтому
вставка и уаление узла происходит за O(logN). У наслюбой путь от узла до
листа должен содержать одинаковое количество черных узлов - так и
достигается балансировка. Если же окрашивать свежие узлы не строго в
красный, а, например, в зависимости от цвета родителя, то у нас
получится, что какой-то путь содержит больше черных узлов, чем
другие. Дерево расбалансирутеся и весь смысл в нем пропадает.


Возвращаемся к вставке.
Если родительский узел черный, а наш новый узел красный - все
отлично. Если же родительский узел красный, то:

- смотрим на "дядю" - узел, который находится на одном и том же уровне с
  "папой" и у которого с ним общий "дедушка". Если "дядя" тоже красный,
  то перекрашиваем папу и дядю в черный цвет и больше не паримся.

- дядя оказался черным.

Тогда геморрой, дерево придется вращать.
Папа станет дедушкой, свеженький потомок встанет на место папы. Дедушка
же встанет на место дяди. Дядя так и останется связанным с дедушкой, так
что подвинув дедушку, на уровень глубины вниз - на место дяди - вся ветка
дяди тоже сместится на уровнь ниже.

И при этом надо следить, чтоб все узлы по-прежнему были окрашены
правильно.
Если дедушка был черным, то папа, вставая на его место, должен
перекраситься в черный. Мы помним, что наш дядя тоже был черным, значит,
дедушку, который станет связывать дядю и папу, придется перекрашивать в
красный - потому что иначе у нас на одной ветке получится слишком много
черных узлов.

Для полного понимания смотрим сюда
https://habr.com/ru/company/otus/blog/472040/

** Вставка на лиспе
Согласно описанным выше правилам, закодиваем алгоритм вставки.
Каждый узел будет содержать значение, цвет и два
указателя на потомков и один - на предка.

По умолчанию все узлы черные.
#+NAME: r_b_node
#+BEGIN_SRC lisp :noweb yes
    (defstruct (node (:print-function (lambda (n s d)
                                        (print-tree s n d))))
      (elt nil)
      (color 'black)
      (parent nil) (l nil) (r nil))

#+END_SRC

Пишем процедуру для печати дерева - обычная печать не подойдет, поскольку
вызовет нескончаемую рекурсию из-за наличия поля "parent" в структуре.

#+NAME: print-r-b-tree
#+BEGIN_SRC lisp :noweb yes
  (defun print-space (n)
    (if (= n 0)
        t
        (progn
          (format t " ")
          (print-space (decf n)))))

  (defun print-node-values (stream string node)
    (if (null node)
        (format stream "NIL ~%")
        (format stream "#~A < ~A > ~%"
                string
                (node-elt node))))


  (defun print-child (stream string child level)
    (print-space  (expt level 2))
    (format stream "~A " string)
    (print-tree-rec stream child level))

  (defun print-node-color (stream string color level)
    (print-space  (expt level 2))
    (format stream "~A ~A ~%" string color))

  (defun print-parent-values (stream parent level)
    (print-space (expt level 2))
    (format stream ":PARENT ")
    (print-node-values stream "" parent))

  (defun print-tree-rec (stream tree level)
    (if (null tree)
        (print-node-values stream "" tree)
        (progn
          (print-node-values stream "NODE" tree)
          (print-node-color stream ":COLOR" (node-color tree) (+ 1 level))
          (print-parent-values stream (node-parent tree) (+ 1 level))
          (print-child stream ":LEFT" (node-l tree) (+ 1 level))
          (print-child stream ":RIGHT" (node-r tree) (+ 1 level))
          (format stream "~%" ))))

  (defun print-tree (stream tree d)
    (format stream "~%" )
      (print-tree-rec stream tree d))

  (print-tree t (make-node :elt 3) 1)
#+END_SRC

Реализуем суб-процедуры. Процедуры перекрашивания узла в черный и
красный цвета:

#+NAME: recolor_node
#+BEGIN_SRC lisp :noweb yes
  (defun recolor-red (node)
    (setf (node-color node) 'red))

  (defun recolor-black (node)
    (setf (node-color node) 'black))
#+END_SRC

Предкат, который будет определять цвет узла:

#+NAME: predicats
#+BEGIN_SRC lisp :noweb yes
  (defun red? (node)
    (equal (node-color node) 'red))

  ;; (defun black? (node)
  ;;   (if (null node)
  ;;       nil
  ;;       (equal (cdr (node-elt node)) 'b)))

  (defun black? (node)
    (equal (node-color node) 'black))

  (defun on-one-side? (grand-dad dad new-node)
    (if (null grand-dad)
        (or (equal (node-l dad) new-node)
            (equal (node-r dad) new-node))
        (or (and (equal (node-l grand-dad)
                        dad)
                 (equal (node-l dad)
                        new-node))
            (and (equal (node-r grand-dad)
                        dad)
                 (equal (node-r dad)
                        new-node)))))

  (defun leaf? (node)
    (if (null node)
        nil
        (and (black? node) (null (node-elt node)))))
#+END_SRC

Процедуры, возвращающие дядю, папу, дедушку, брата узла или его значение:
#+NAME: get_relatives
#+BEGIN_SRC lisp :noweb yes
  (defun get-dad (node)
    (node-parent node))

  (defun get-brother (node)
    (let ((dad (get-dad node)))
      (if (null dad)
          nil
          (let* ((left (node-l dad))
                 (elt (node-elt left)))
            (if (equal elt (node-elt node))
              (node-r dad)
              (node-l dad))))))

  (defun get-grand-dad (node)
    (node-parent (get-dad node)))

  (defun get-uncle (node)
    (let ((dad (get-dad node))
          (grand-dad (get-grand-dad node)))
      (if (equal (node-elt (node-l grand-dad))
                 (node-elt dad))
          (node-r grand-dad)
          (node-l grand-dad))))

#+END_SRC

Процедура добавляет два листа к узлу:

#+NAME: add_leafs
#+BEGIN_SRC lisp :noweb yes
  (defun add-leafs (node)
    (setf (node-l node) (make-node :parent node)
          (node-r node) (make-node :parent node))
    node)
#+END_SRC

Процедура, устанавливающая новые "родственные связи" между
узлами. Т.е. просто заменяет заданный потом у узла.
Принимает родительский узел, узел, который надо заменить, и узел, которым заменяем.

#+NAME: set_new_child
#+BEGIN_SRC lisp :noweb yes
  (defun set-new-child (parent-node old-child-node new-child-node)
    ;; (format t "set-new-child parent node: ")
    ;; (print-tree t parent-node 1)
    ;; (format t "set-new-child old node: ")
    ;; (print-tree t old-child-node 1)
    ;; (format t "set-new-child new node: ")
    ;; (print-tree t new-child-node 1)
    (if (equal (node-elt (node-l parent-node)) (node-elt old-child-node))
        (progn
          (format t "set left child ~%")
          (setf (node-parent new-child-node) parent-node
                (node-l parent-node) new-child-node)
          ;; (format t "new parent node: ")
          ;; (print-tree t parent-node 1)
          )
        (progn
          (format t "set right child ~%")
          (setf (node-parent new-child-node) parent-node
                (node-r parent-node) new-child-node))))
#+END_SRC

Теперь пишем процедуру, которая перекрасит папу и дядю вставляемого узла
в черный, если они оба красные. В этом случае, перекрасив их, мы без
проблем сможем вставить новый красный узел.

#+NAME: recolor_black_dad_and_uncle
#+BEGIN_SRC lisp :noweb yes
  (defun recolor-black-dad-and-uncle (node)
    (let* ((dad-node (get-dad node))
           (uncle-node (get-uncle node)))
      (recolor-black dad-node)
      (recolor-black uncle-node)))
#+END_SRC

Процедуру, вращающую поддерево, если:
- дядя узла - черный
- папа, дедушка и новый узел находятся на "одной стороне", т.е. на одной
  ветке.

Это означает, что, например, если мы будем строго идти по левым потомкам,
то мы пройдем через дедушку, папу и новый узел. Или аналогично если будем
идти по правым потомкам.

В этом случае:
- папа становится на место дедушки и меняет свой цвет (с красного на
  черный)
- дедушка становится вместо брата и меняет свой цвет (с черного на
  красный). При этом связь дедушки и дяди сохраняется.

~Вопрос 1~: Откуда мы знаем, что дедушка точно был черным? Вдруг он был красным?
Ответ: красным он быть не может. Потому что у нас красный папа (будь папа
черным, мы без проблем вставили в дерево новый красный узел). А у красных
узлов не может быть красных детей. Следовательно, дедушка у нас точно был
черным.

~Вопрос 2~: Как можно заменить брата на дедушку? Куда деть брата? Не
потеряем ли мы эту ветку?

Ответ: нет, не потеряем.
Папа может быть красным только если двое его детей -  это листья,
т.е. черные узлы без значений.

Да, в результате перебалансировки дерева мы можем перекрашивать узлы. И в
какой-то момент у нас возникнет ситуация, когда у нас будет красный узел,
из которого будут исходить два черных узла, которые не будут являться
листьями. Только вот уже никакой потомок к этому узлу мы не присоединим -
потомки все заняты.

Поэтому заменяя брата на дедушку, мы ничего не теряем. Брат - это лист,
пустой черный узел.

Чтоб это все выполнить мы:
- перекрашиваем папу в черный
- перекрашиваем деда в красный
- папа заменяет дедушку - теперь дедушка его потомок. А для прадедушки наш
  папа стал сыном.
- дедушка заменяет брата - теперь наш папа его отец. А дедушка - наш
  брат.
- устанавливаем в качестве потомков дедушки 2 черных листа

#+NAME: rotate_if_uncle_black_one_side
#+BEGIN_SRC lisp :noweb yes
  (defun rotate-if-uncle-black-one-side (node)
    (let* ((dad (get-dad node))
           (grand-dad (get-grand-dad node))
           (grand-grand-dad (get-dad grand-dad)))
      (format t " rotate-if-uncle-black-one-side grand dad: ")
      (print-tree t grand-dad 1)
      ;; перекрасили папу и дедушку
      (recolor-black dad)
      (recolor-red grand-dad)
      (let ((grand-dad-elt (node-elt grand-dad))
            (grand-dad-color (node-color grand-dad)))
        ;; (format t "copy grand-dad ~%")
        ;; (print-tree t copy-grand-dad 1)
        ;; дедушка - это корень (т.е. нет прадедушки)?
        (if (null grand-grand-dad)
            ;; папа становится новым корнем
            (progn
              (make-new-root grand-dad dad)
              (if (null (node-elt (node-l grand-dad)))
                  (setf (node-l grand-dad) (make-node :elt grand-dad-elt
                                                :color grand-dad-color))
                  (setf (node-r grand-dad) (make-node :elt grand-dad-elt
                                                      :color grand-dad-color))))

              ;; ;; копия дедушки становится на место брата
              ;; (format t " rotate-if-uncle-black-one-side dad: ")
              ;; (print-tree t dad 1)
              ;; dad)
            (progn
            ;; папа заменяет дедушку
            (set-new-child grand-grand-dad grand-dad dad)
            ;; дедушка заменяет брата
            (set-new-child dad (get-brother node) grand-dad)
            (format t " rotate-if-uncle-black-one-side dad: ")
            ;; устанавливаем дедушке вместо потомков два черных листа
            (add-leafs grand-dad)
            (print-tree t dad 1)
            dad)))))

  (defun make-new-root (old-node new-node)
    (setf (node-color old-node) (node-color new-node)
          (node-elt old-node) (node-elt new-node)
          (node-l old-node) (node-l new-node)
          (node-r old-node) (node-r new-node)))
#+END_SRC

Но есть ситуация хуже, чем когда папа красный, дядя черный, и дедушка,
папа и новый находятся на одной ветке.

Может быть, что папа и дедушка не на одной ветке, папа по-прежнему
красный, а дядя - по-прежнему черный.
Т.е. чтоб от деда дойти до нового узла, мы должны пройти сначала по
правой ветке, а потом по левой. Или наоборот.

В этом случае нужно совершить большой поворот. Сначала мы приводим
поддерево в состояние, когда у нас папа и дед на одной стороне, а затем
уже вращаем поддерево с помощью процедуры
~rotate-if-uncle-black-one-side~, которую написали выше.

Для этого нам банально нужно поменять папу и новый узел местами. Новый
узел станет папой, а папа - встанет вместо нового узла.
А уже из этого состояния мы вызовем ~rotate-if-uncle-black-one-side~.

#+NAME: rotate_if_uncle_black_diffrnt_sides
#+BEGIN_SRC lisp :noweb yes
  (defun rotate-if-uncle-black-diffrnt-sides (node)
    (let ((dad (get-dad node))
          (grand-dad (get-grand-dad node)))
      (set-new-child grand-dad dad node)
      (add-leafs dad)
      (if (< (get-value (node-elt dad))
             (get-value (node-elt node)))
          (progn
            (setf (node-l node) dad)
            (rotate-if-uncle-black-one-side dad))
          (progn
            (setf (node-r node) dad)
            (rotate-if-uncle-black-one-side dad)))))
#+END_SRC

#+NAME: insert_in_red_black_tree
#+BEGIN_SRC lisp :noweb yes :tangle r-b-tree.lisp
  <<print-r-b-tree>>
  <<r_b_node>>
  <<recolor_node>>
  <<predicats>>
  <<get_relatives>>
  <<add_leafs>>
  <<set_new_child>>
  <<recolor_black_dad_and_uncle>>
  <<rotate_if_uncle_black_one_side>>
  <<rotate_if_uncle_black_diffrnt_sides>>

  (defun recombine-tree (tree new-node)
    (print-tree t tree 1)
    (let* ((dad tree)
           (grand-dad (get-grand-dad new-node))
           (uncle (get-brother dad)))
      ;; вставка была в корень корень
      (cond ((and (black? dad) (null uncle) (null grand-dad))
             tree)
            ;; дядя и папа- красные
            ((and (red? dad) (red? uncle))
             (progn
               (format t "both are red ~%")
               (recolor-black-dad-and-uncle new-node)))
            ;; дядя черный, папа красный,
            ;; папа, дед и новый узел - на одной стороне
            ((and (on-one-side? grand-dad dad new-node)
                  (black? uncle)
                  (red? dad))
             (progn
               (format t "one side ~%")
               (rotate-if-uncle-black-one-side new-node)))
            ;; дядя черный, папа красный,
            ;; папа, дед и новый узел - на разных сторонах
            ((and (not (on-one-side? grand-dad dad new-node))
                  (black? uncle)
                  (red? dad))
             (progn
               (format t "diffrnt sides ~%")
               (rotate-if-uncle-black-diffrnt-sides new-node)))
            ;; папа черный, ничего пережелывать не надо
            (t tree))))

  (defun insert-in-red-black-tree-rec (tree elt)
    (if (null tree)
        (add-leafs (make-node :elt elt))
        (let ((node-value (node-elt tree)))
          (format t "tree elt ~A ~%" node-value)
          (cond ((< elt node-value)
                 ;; левая ветка
                 (if (leaf? (node-l tree))
                     ;; вставка
                     (progn
                       ;; вставили новую красную ноду и добавили к ней
                       ;; 2 черных листа
                       (format t "left leaf ~%")
                       (setf (node-l tree)
                             (add-leafs (make-node :elt elt
                                                   :color 'red
                                                   :parent tree)))
                       (recombine-tree tree (node-l tree)))
                     ;; иначе идем дальше
                     (insert-in-red-black-tree-rec (node-l tree) elt)))

                ((> elt node-value)
                 ;; правая ветка
                 (if (leaf? (node-r tree))
                     ;; вставка
                     (progn
                       (format t "right leaf ~%")
                       (setf (node-r tree)
                             (add-leafs (make-node :elt elt
                                                   :color 'red
                                                   :parent tree)))
                       (recombine-tree tree (node-r tree)))
                     ;; иначе идем дальше
                     (insert-in-red-black-tree-rec (node-r tree) elt)))
                (t tree)))))

  (defun make-red-black-tree (lst)
    (defun make-red-black-tree-rec (tree lst)
      (if (null lst)
          tree
          (progn
            (insert-in-red-black-tree-rec tree (car lst))
            (make-red-black-tree-rec (cdr lst)))))
    (make-red-black-tree-rec (insert-in-red-black-tree-rec nil (car lst))
                             (cdr lst)))


  (setf test-tree (insert-in-red-black-tree-rec nil 1))
  (insert-in-red-black-tree-rec test-tree 2)
  (insert-in-red-black-tree-rec test-tree 3)
  (insert-in-red-black-tree-rec test-tree 4)
  (insert-in-red-black-tree-rec test-tree 5)


  ;; (get-brother (node-r test-tree))

  ;; (insert-in-red-black-tree-rec nil 1)

  ;; (make-red-black-tree '(1 2 3 4 5))
#+END_SRC
